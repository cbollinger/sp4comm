#+CATEGORY: SP4COMM W8

#+LATEX_HEADER: \usepackage{enumitem}
#+LATEX_HEADER: \usepackage[table]{xcolor}
#+LaTeX_HEADER: \usepackage{tcolorbox}

#+LaTeX_HEADER: \usepackage[tikz]{bclogo}
#+LaTeX_HEADER: \usepackage[customcolors]{hf-tikz}

#+LaTeX_HEADER: \usepackage{amsmath}
#+LaTeX_HEADER: \usepackage{amsxtra}
#+LATEX_HEADER: \usepackage{mathtools} 
#+LATEX_HEADER: \usepackage{dsptricks,dspfunctions,dspblocks}

# +Latex: \newenvironment{gbar}[2]{\def\FrameCommand{{\color{#1}\vrule width 3pt}\colorbox{#2}}\MakeFramed{\advance\hsize-\width\FrameRestore}}{\endMakeFramed}
#+Latex: \renewcommand{\arraystretch}{1.2}
#+Latex: \everymath{\displaystyle}

#+SETUPFILE: ~/.emacs.d/git-submodules/org-html-themes/org/theme-readtheorg.setup

* Week 8 Module 6: 
** Digital Communication Systems
*** Introduction to digital communications
**** The success factors for digital communications
1. Power of the DSP paradigmw
   - integers are easy to *regnerate*
   - good phase control
   - adaptive algorithms
2. Algorithmic nature of DSP is a perfect match with information therory:
   - Image Coding: JPEG's entropy coding
   - Encoding of of accustic or video informatiion: CD's and DVD's error
     correction
   - Communication Systems: trellis-coded modulation and Vierbi coding
3. Hardware advancement
   - minituarization
   - general-purpose platforms
   - power efficiency
     
**** The analog channel constraints
+ unescapable "limits" of physical channels:
  - *Bandwith:* the signal that canbe send over a channel has a limited frequency band
  - *Power:* the signal has limited power over this band, e.g. due to power limit
    of the equipment
+ Both constraints will affect the final \textcolor{blue}{capacity} of the
  channel.
+ The maximum amound of information that can be reliably delivered over a
  channel - bits per second -
+ Bandwidth vs. capacity:
  - small sampling period $T_s \Rightarrow$ high capacity
  - but the bandwidth signal grows as $\frac{1}{T_s} \Rightarrow$
    $\Omega_N =  \frac{\pi}{T_s}$
    
**** The design Problem
- We are going to adapt the all-digital paradigm
- Converting the specs to digital design
  
#+begin_src octave :exports results :results file
    pkg load signal

    #---------------- Continous Time Calculation -------------
    Fp    = 10e3;             # spacing pseudo continous signal 
    Fv    = -100:1/Fp:100;    # frequency vector 
    F_max = 150;              # F_max
    F_min = 50;               # F_min
    x1 = rectpuls(Fv,F_max);
    x2 = rectpuls(Fv,F_min);
    x = x1 - x2;

    ## #---------------- A/D Conversion ------------------------
    fs = 2*F_max;       # Myquist
    ## #---------------- Discrete Time Calculation -------------

    N     = 64;                # Sequence length
    w     = -pi:1/N:pi;
    w_max = 2*pi*(F_max/fs);
    w_min = 2*pi*(F_min/fs);
    y1    = rectpuls(w,w_max);
    y2    = rectpuls(w,w_min);
    y     = y1-y2;

    figure( 1, "visible", "off" ); # Do not open the graphic window in org

    subplot(2, 1, 1)
    plot(Fv,x, "linewidth", 3)
    axis([-100, 100 0 1.5])
    xlabel("Hz")
    set(gca, "fontsize", 16)
    set(gca, "YTick", 0:1)
    set(gca, "XTick", -100:25:100)
    set(gca,'XTickLabel',{'-100','-75','-50','-25', '0', '25', '50', '75','100'})
    title("Continous Time")

    subplot(2, 1, 2)
    plot(w,y, "linewidth", 3)
    axis([-pi, pi 0 1.5])
    xlabel("rad")
    set(gca, "fontsize", 16)
    set(gca, "XTick", -pi:pi/2:pi)
    set(gca, "YTick", 0:1)
    set(gca,'XTickLabel',{'-\pi', '-\pi/2', '0','\pi/2', '\pi'})
    title("Discrete Time")

    print -dpng "-S800,400" ./image/6_1_band_restriction.png;
    ans = "./image/6_1_band_restriction.png";
#+end_src

#+results:
[[file:./image/6_1_band_restriction.png]]

- with:
  - Sampling Frequency $F_S \ge 2f_{max}$
  - Continuous Time $F_s/2$: Nyquist frequency
  - Maximum Frequency: $\frac{F_s}{2} \Rightarrow \pi$
  - Bandwidth: $\omega_{min,max} 2\pi\frac{f_{min,max}}{F_s}$ 

- Transmitter design
  - convert a bitstream into a sequence of symbols a[n] via a mapper
  - model a[n] as \textcolor{blue}{white random sequence} $\Rightarrow$ add a
    \textcolor{blue}{scrambler}
  - no we need to convert a[n] into a continuous-time signal within the constraints

      #+BEGIN_SRC ditaa  :file ./image/6.1_transmitter-01.png 

                  +--------------+       +--------------+       +----------+
                  |              |       |              | a[n]  |          |
        ..01100-->+  Scrambler   +---+-->+  Mapper      +------>+     ?    +------> s(t)
        01010..   |              |   ^   |              |       |          |
                  +--------------+   |   +--------------+       +----------+
                                     |
                                     |
                            random binary sequence
#+END_SRC

If we assume that the data is randomized and therefore the symbol sequence is a
white sequence, we know that the power spectral density is simply equal to the
variance.  And so the power of the signal will be constant over the entire
frequency band.  But we actually need to fit it into the small band here as
specified by the bandwidth constraint.  So how do we do this?  Well, in order to
do that, we need to introduce a new technique called
\textcolor{blue}{upsampling}, and we will see this in the next module.

We are talking about digital communication systems and in this lesson we will
talk about how to fulfill the \textcolor{blue}{bandwidth constraint}. The way we
are going to do this is by introducing an operation called
\textcolor{blue}{upsampling} and we will see how upsampling allows us to fit the
spectrum generated by the transmitter onto the band allowed for by the channel.
*** Controlling the bandwidth
- Shaping the bandwidth Remember that our assumption is that the signal
  generated by the transmitter is a wide sequence and therefore its power
  spectral density will be \textcolor{blue}{constant and full band}. In order to
  meet the bandwith constraint, we need to shrink the support of the power
  spectral density.
    - the answer is \textcolor{blue}{multirate} techniques
**** Upsampling
- Our Problem
- bandwith constraint requires us to control the spectral support of a signal
  - we need to be able to shrink the support of a full-band signal

- Upsampling can be obtained by interpolating a discrete time sequence to get a
  continuous time signal. And resample the signal with a sampling period which
  is k-times smaller than the original interpolation sample.

- Or we do it entirly digitally.
  1. we need to "increase" the number of samples by k
  2. obviously $x_U[m] = x[n] when m multiple of K$
  3. for lack of better strategy, put zeros elsewhere

- Upsampling in the time domain
  #+BEGIN_SRC octave :exports results :results file
    pkg load signal

    clear all, close all;
    N = 64;
    n = -N/2:N/2-1;                                      % Time index
    L = 3;                                           % Up-sampling factors
    x = sin(2*pi*n/64) + sin(3*2*pi*n/64)/3;       % Generating the original signal
    v1 = upsample(x,L);                              % Up-sampling
    r = -(length(v1))/2:(length(v1))/2-1;                              % new Time index

    figure( 1, "visible", "off" ); # Do not open the graphic window in org

    subplot(2,1,1), stem(n,x,"linewidth", 3, "filled", "markersize", 6), ylabel('x[n]')
    title('Original signal x[n]')
    set(gca, "fontsize", 24);
    axis([-8, 8, -1, 1]);
    set(gca, 'YTick', 0:1.5);
    set(gca, 'XTick', -8:2:8);

    subplot(2,1,2), stem(r,v1,"linewidth", 3, "filled", "markersize", 6), ylabel('v_1[r]')
    title('Upsampling by 2')
    axis([-32, 32, -1, 1]);
    set(gca, "fontsize", 24);
    set(gca, 'YTick', 0:1.5);
    set(gca, 'XTick', -40:10:40);
    grid off;
    title('Excerpt upsampled by 4');

    print -dpng "-S800,400" ./image/6_2_upsampling_01.png;
    ans = "./image/6_2_upsampling_01.png";
#+end_src

   #+results:
[[file:./image/6_2_upsampling_01.png]]


- Upsampling in the digital domain: Frequency Domain

  #+begin_src latex 
    \begin{align*}
      X_U(e^{j\omega}) &= \sum_{m=-\infty}^{\infty} x_U[m]e^{-j\omega m} \text{ with } x_U = 0 \text{ if } m \neq nK\\
                     &= \sum_{m=-\infty}^{\infty} x[n]e^{-j\omega nK} \\
                     &= X(e^{j\omega K})
    \end{align*}
  #+end_src
This is simply a scaling of the frequency axis by a factor of K. Graphical
interpretation: since we are multiplying the frequency axis by a factor of K,
there will be a shrinkage of the frequency axis.

#+begin_src octave :exports results :results file
  pkg load signal
    clear all, close all;                          # Size of the sequence
    w = 4/12/pi
    t = -3/4*pi:1/1000:3/4*pi    # Axis Discrete Time Frequency Domain
    K = 3;                        # Upsampling konstant
    # Generation of the original Frequency response
    x1 = sin(2*pi*w*t+pi/2);
    x2 = 1/K*sin(2*pi*3*w*t - pi/2);
    x3 = x1 +x2

    w = [-pi:1/1000:(-3/4*pi)-1/1000, t, 3/4*pi+1/1000:1/1000:pi]
    X = [zeros(1,(length(w)-length(t))/2), x3, zeros(1,(length(w)-length(t))/2)];

    X2  = [X,X,X,X,X]
    w2  = [-5*pi:1/1000:5*pi-1/1000];
    w3h = -K*pi:K*pi+1;
    X3h = zeros(1,length(w3h));

    X3 = [X,X,X]
    w3 = [-pi:1/(K*1000):pi-1/3000];
    HR = rectpuls(w3,2*pi/3);

    figure( 1, "visible", "off" )     # Do not open the graphic window in org

    subplot(4, 1, 1);
    plot(w, X, "linewidth", 3);
    axis([-pi,pi,0,1]);
    set(gca, "fontsize", 20)
    set(gca,'XTick',-pi:pi/4:pi)
    set(gca,'XTickLabel',{'-\pi','3/4\pi','-\pi/2', '-1/4\pi','0', '1/4\pi','\pi/2','3/4\pi','\pi'})
    set(gca, 'YTick', 0:1);
    ylabel('X(e^j^\omega)');
    title("Frequency response of the original signal")
    grid off;

    subplot(4, 1, 2);
    plot(w2, X2, "linewidth", 3, w3h, X3h, "linewidth", 6);
    axis([-5*pi,5*pi,0,1]);
    set(gca, "fontsize", 20)
    set(gca,'XTick',-5*pi:pi:5*pi)
    set(gca,'XTickLabel',{'-5\pi','-4\pi','-3\pi','-2\pi','-\pi','0', '\pi','2\pi','3\pi','4\pi','5\pi'})
    set(gca, 'YTick', 0:1);
    ylabel('X(e^j^\omega)');
    title("2-\pi periodic signal")
    grid off;

    subplot(4, 1, 3);
    plot(w3, X3, "linewidth", 3, w3, HR, '--', 'linewidth', 3, "color", "r");
    axis([-pi,pi,0,1]);
    set(gca, "fontsize", 20)
    set(gca,'XTick',-pi:pi/2:pi)
    set(gca,'XTickLabel',{'-\pi','-\pi/2','0','\pi/2','\pi'})
    set(gca, 'YTick', 0:1);
    ylabel('X_U(e^j^\omega)');
    title("Upsampled by 3");
    text(pi/3+0.1, -0.4, '\fontsize{24}\it\pi/K   ',  "color",  "red",  "interpreter",  "tex",  "horizontalalignment",  "center");
    text(-pi/3-0.1, -0.4, '\fontsize{24}\it-\pi/K   ',  "color",  "red",  "interpreter",  "tex",  "horizontalalignment",  "center");
    grid off;
    ans = "./image/6_2_upsampling_freq_02.png";

    subplot(4, 1, 4);
    plot(w3, X3.*HR, "linewidth", 3);
    axis([-pi,pi,0,1]);
    set(gca, "fontsize", 20)
    set(gca,'XTick',-pi:pi/4:pi)
    set(gca,'XTickLabel',{'-\pi','3/4\pi','-\pi/2', '-1/4\pi','0', '1/4\pi','\pi/2','3/4\pi','\pi'})
    set(gca, 'YTick', 0:1);
    ylabel('X_U(e^j^\omega)');
    title("Frequency response of the upsampled and filtered signal");
    grid off;

    print -dpng "-S800,600" ./image/6_2_upsampling_freq_02.png;
    ans = "./image/6_2_upsampling_freq_02.png";
#+end_src

#+results:
[[file:./image/6_2_upsampling_freq_02.png]]


- $\frac{\pi}{K}$: Filter Cut-Off Frequency
- The bandwidth of the signal was shrinked by factor K=3: from $\frac{3}{4} \pi$
  to $\frac{1}{4} \pi$

- Upsampling in the digital domain: Time Domain
  1. insert K-1 zeros after every sample
  2. ideal lowpass filtering with $\omega_c = >frac{\pi}{K}$

     #+begin_src latex
       \begin{align*}
              x^[n] &= x_U(n) * sinc(n/K) \\
                    &= x_U[i] sinc \left( \frac{n-i}{K}\right) \\
                    &= x[m] sinc \left( \frac{n}{K} - m\right) \text{, with } i = mK \\ 
       \end{align*}
     #+end_src

     Which is exactely the same formula when using an interpolator and a sampler.
**** Fitting the transmitter spectrum
The bandwidth constraint says that only frequencies between $F_{min}$ and
$F_{max}$ are allowed. To translate it to the digital domain, follow the
preceeding steps:
- let $W = F_{max} - F_{min}$
- pick $F_s$ so that:
  - $F_s > 2 F_{max}$
  - $F_s = KW$, $k \in \mathbb{N}$
- $\omega_{max} - \omega_{min} = 2\pi \frac{W}{F_s} = \frac{2\pi}{K}$
- \textcolor{blue}{we can simply upsample by K}

  #+ATTR_LATEX: :options [logo=\bcbook, couleur=yellow!10, barre=snake, arrondi=0.1]{Bandwith constrainth}
  #+BEGIN_bclogo
  And so we can simply upsample the sample sequence by K, so that its bandwidth
  will move from 2pi to 2pi/K, and therefore, its width will fit on the band
  allowed for by the channel.
  #+END_bclogo

#+BEGIN_SRC ditaa  :file ./image/6.1_transmitter-02.png 

            +--------------+       +--------------+
            |              |       |              | a[n]   -----  
  ..01100-->+  Scrambler   +---+-->+  Mapper      +------>( K â¬† ) ---+
  01010..   |              |   ^   |              |        -----     |
            +--------------+   |   +--------------+                  |
                               |                                     |
                        random binary sequence                       |
                                                                     |
     +---------------------------------------------------------------+
     |
     |     +------------+                    +---------+
     |     |     |      | b[n]  -----   s[n] |         |
     +---->+   +-+-+    +----->(  X  ) ----->+   D/A   +----> s(t)
           |  -|-+-|->  |       --+--        |         |
           |     |      |         ^          +---------+
           +------------+         |         
                                  |         
                pi/k          cos(wn)




#+END_SRC

#+ATTR_LATEX: :options [leftmargin=3cm,labelwidth=2.7cm,itemindent=-2pt]
- Scrambler :: Randomizes the data
- Mapper :: Segments the bit-stream into consecutive groups of M bits. And this
  bits select one of $2^M$ possible signaling values. The set of all possible
  signaling values is called the \textcolor{blue}{alphabet}.
- a[n] :: The actual discrete-time signal. The sequence of symbols to be transmitted.
- K :: The uppsampler narrows the spectral occupancy of the symbol
  sequence. The following low pass filter is known as the
  \textcolor{blue}{shaper}, since it determines the time domain shape of the
  transmitted symbols.
- b[n] :: The \textcolor{blue}{baseband} signal. Produced
- s[n] :: The \textcolor{blue}{passand} signal. $s[n] = Re\{c[n]\} = Re\{b[n]e^{j\omega_c n}\}$ The signal which is
  fed to the D/A converter is simply the real part of the complex bandpass
  signal. With $\omega_c = \frac{\omega_max - \omega_min}{2}$ 

- Data Rates
  - up-sampling does not change the data rate
  - we produce (and transmitt) W symbols per seconds
  - W is sometimes called the \textcolor{blue}{Baud Rate} of the system and is equal to the
    available bandwidth.

- Raised Cosine    

*** Controlling the power
**** Noise and probability of error
- Transmitter reliability
  - transmitter sends a sequence of symbols a[n]
  - receiver obtains a sequence $\hat{a}[n]$
  - even if no distortion we can't avoid noise: $\hat{a}[n] = a[n] + \eta[n]$
  - when noise is large, we make an error
- Probability of error depends on:
  - power of the noise with respect to the power of the signal
  - decoding strategy
  - alphabet of transmission symbols
***** Signaling alphabets
- we have a (randomized) bitstream coming in
- we want to send some up-sampled and interpolated samples over the channel
- how do we get from bit-stream to samples: How does the mapper works
- \textcolor{blue}{mapper:}
  - split incoming bitstream into chunks
  - assign a symbol a[n] from a finite alphabet $A$ to each chunk.
- \textcolor{blue}{slicer:}
  - receive a value $\hat{a}$[n]
  - decide which symbol from $A$ is "closest" to $\hat{a}[n]$

***** Example: two-level signaling
  - \textcolor{blue}{mapper:}
    - split incoming bitstream into *single bits*
    - a[n] = G of bit is 1, a[n] = -G if bit is 0
  - \textcolor{blue}{slicer:}
    #+begin_src latex
      \begin{equation*}
        n-th \text{ bit} =
        \begin{cases}
          1 \text{, if } \hat{a}[n] > 0 \\
          0 \text{, otherwise }
        \end{cases}
      \end{equation*}
    #+end_src

- Porbability Error
  
  #+begin_src latex
    \begin{align*}
      P_{err} &=   P\left[\eta[n] < -G | \text{ n-th bit is 1} \right]
                + P\left[\eta[n] > G | \text{ n-th bit is 0} \right] \\
             &= \left(P\left[\eta[n] < -G \right] + P\left[\eta[n] > G\right] \right) / 2 \\
             &= P\left[\eta[n] > G\right] \\
              &= \int_G^{\infty} \frac{1}{\sqrt{2\pi\sigma_0^2}} e^{-\frac{\tau^2}{2\sigma_0^2}} d\tau
                \text{, with the PDF for the Gaussian Distribution with the known variance}\\
             &= erfc(G/\sigma_0) \text{, Numerical Packages: The Error Function}
    \end{align*}
  #+end_src

#+ATTR_LATEX: :options [logo=\bcbook, couleur=yellow!10, barre=snake, arrondi=0.1]{Probability Error}
#+BEGIN_bclogo
Is some function of the ratio between the amplitude of the signal and the standard deviation of the noise.
#+END_bclogo

  
- transmitted power
  #+begin_src latex
    \begin{align*}
      \sigma^2 &=   G^2 P\left[\text{ n-th bit is 1} \right]
                  + G^2 P\left[\text{ n-th bit is 0} \right] \\
               &= G^2
    \end{align*}
     #+end_src

#+begin_src latex
  \begin{tcolorbox}[colback=red!5!white,colframe=red!75!black,title=Probability of Error]
    \begin{equation*}
      P_{err} = erfc(\sigma_s/\sigma_0) = erfc(sqrt{SNR})
    \end{equation*}
  \end{tcolorbox}
#+end_src
  

And since we are in a log log scale, we can see that the probability of error
decays exponentially with the signal to noise ratio.  Absolute rate of decay
might change, in terms of the linear constants involved in the curve.  The trend
will stay the same, even for more complex signaling schemes

***** Lesson learned:
- to reduce the probability of error increase G
- increasing G increases the power
- we can't go above the channel's power constraint.

  
***** Multilevel signaling
- binary signaling is not very efficient (one bit at a time)
- to increase the throughput we can use multilevel signaling
  
#+ATTR_LATEX: :options [leftmargin=3cm,labelwidth=2.7cm,itemindent=-2pt]
- the general idea ::
  We take now larger chunks of bits, and therefore, we have alphabets, that have
  a higher cardinality. So more values in the alphabet, means more bits per
  symbol, and therefore a higher data rate. But not to give the ending away, we
  will see that the power of the signal will also be dependent of the size of
  the alphabet, and so in order not to exceed the certain probability of error,
  given the channel's power of constraint. We will not be able to grow the
  alphabet indefinitely, but we can be smart in the way we build this
  alphabet. And so we will look at some examples.

* Week 8 Module 7: 
** Image Processing
