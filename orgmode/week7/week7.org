#+CATEGORY: SP4COMM W7

# #+LATEX_CLASS: koma-report                                   
# #+LATEX_HEADER: \input{../dsp_setup.tex}
# #+LATEX_HEADER: \input{../dsp_table.tex}

* Sampling and Quantization
Interpolation describes the process of building a continuous-time signal *x(t)* from
a sequence of samples *x[n]*. In other words, interpolation allows moving from the
discrete-time world to the continuous-time world. Interpolation raises two interesting
questions:

The first one is how to interpolate between samples?
- In the case, of two samples, this is simple enough and there is there is a straight line
  that goes between these two samples.
- In the case of three samples, similarly, you have a parabola that goes through these 3
  samples.
- If you have many samples, you can try to do the same and go through all samples but you
  see this is a trickier issue compared to what we have done with two or three
  samples.
The second question is:
- is there a minimum set of values you need to measure the function at so that you can
  perfectly reconstruct it.

Later on in the module, we are going to study sampling, i.e. the process of moving from a
continuous-time signal to a sequence of samples. In other words, sampling allows moving
from the continuous-time world to the discrete-time world. Suppose we take equally-spaced
samples of a function *x(t)*. The question is when is there a one-to-one
relationship between the continuous-time function and its samples, i.e. when do the
samples form a unique representation of the continuous-time function? To answer this
question, we are going to use all the tools in the toolbox that we have looked at so far:
- Hilbert spaces
- projections
- filtering
- sinc functions
- and so on.
Everything comes together in this module to develop a profound and very useful result, the
*sampling theorem*.

Before moving to the heart of the topic, let us briefly review its history. The Shannon
sampling theorem has a very interesting history which goes back well before
Shannon. Numerical analysts were concerned about interpolating tables of functions and the
first one to proove a version of the sampling theorem was Whittaker in England
in 1915. Harry Nyquist at Bell Labs came up with the Nyqvist criterion, namely that a
function that has a maximum frequency F0F_0F0​ could be sampled at 2F02F_02F0​. In the
Soviet Union, Kotelnikov proved a sampling theorem. The son of the first Whittaker further
proved results on the sampling theorem. Then Herbert Raabe in Berlin wrote his PhD thesis
about a sampling theorem that, wrong time wrong city, he got zero credit for. Denis Gabor
worked on a version of the sampling theorem in the mid 1940s. Then Claude Shannon, the
inventor of information theory, wrote a beautiful paper that is in the further reading for
this class where the Shannon sampling theorem appears in the form that we use today. Last
but not least, in 1949 Someya in Japan also proved the sampling theorem. You can see that
it’s a very varied history, it’s a fundamental result where many people independently came
up with this result.
** The Continous-Time World
*** Introduction
The continuous-time world is the world we live in, the physical reality of the world, in
contrast with the discrete-time world, the world inside a computer. We are first going to
look at models of the world and compare digital with analog views of the world. Then we
are going to study continuous-time signal processing in greater details. Furthermore, we
will introduce the last form of Fourier transform we have not yet encountered in this
class, the continuous-time Fourier transform.
*** The continous-time paradigm

Two views of the world

#+ATTR_LATEX: :placement [ht] :align  p{5cm}  p{5cm} 
#+CAPTION: Two views of the world 1
| <40>                                   | <40>                      |
|----------------------------------------+---------------------------|
| \myheadcolor\mytextcolor Digital World | \mytextcolor Analog World |
| arithmetic                             | calculus                  |
| combinatorics                          | distributions             |
| computer sience                        | system theory             |
| DSP                                    | electronics               |
|----------------------------------------+---------------------------|


#+ATTR_LATEX: :placement [ht] :align  p{5cm}  p{5cm} 
#+CAPTION: Two views of the world 2
| <40>                                                  | <40>                                              |
|-------------------------------------------------------+---------------------------------------------------|
| \myheadcolor\mytextcolor Digital World                | \mytextcolor Analog World                         |
| countable integer index M                             | real-valued time t [sec]                          |
| sequences $x[n] \in \ell_2(\mathbb{Z})$               | function $x(t) \in L_2(\mathbb{R})$               |
| frequency $\omega \in [-\pi, \pi]$                    | frequency $\Omega \in \mathbb{R} (rad/sec)$       |
| DTFT: $\ell_2(\mathbb{Z}) \rightarrow L_2[-\pi, \pi]$ | FT: $L_2(\mathbb{R}) \rightarrow L_2(\mathbb{R})$ |
|-------------------------------------------------------+---------------------------------------------------|

#+ATTR_LATEX: :options [leftmargin=3cm,labelwidth=2.7cm,itemindent=-2pt]
 - $\ell_2(\mathbb{Z})$ :: Square-Summable infinite sequences
 - $L_2([a,b])$ :: Square-integrable functions over an interval
 - Sampling :: $x(t) \rightarrow x[n]$
 - Interpolation :: $x[n] \rightarrow x(t)$

*** Continuous-time signal processing
#+ATTR_LATEX: :options [leftmargin=5cm,labelwidth=4.7cm,itemindent=-2pt]
- time ::
  real variable t
- signal x(t) ::
  complex function of areal variable
- finite energy ::
  $x(t) \in L_2(\mathbb{R})$
- inner product in  $L_2(\mathbb{R})$ ::
  $\langle x(t), y(t) \rangle = \int_{-\infty}^{\infty} x^*(t)\;y(t)\; dt$
- energy ::
  $||x(t)||^2 = \langle{x(t),x(t)}\rangle$

**** Analog LTI filters

#+begin_src latex
  \begin{align*}
    y(t) &= (x*h)(t) \\
         &= \langle h*(t-\tau),x(\tau)\rangle \\
         &= \int_{-\infty}^{\infty}x(\tau)\;h(t-\tau)\;d\tau
  \end{align*}
#+end_src

**** Fourier analysis
- in discrete time max angular frequency is $\pm \pi$
- in continous time no max frequency: $\Omega \in \mathbb{R}$
- concept is the same:

#+CAPTION: Real-time Fourier Transform
#+begin_src latex
  \begin{tcolorbox}
    \begin{equation*}
      X(j\Omega) = \int_{-\infty}^{\infty}e^{-j\Omega\;t}\;dt
    \end{equation*}
  \end{tcolorbox}
#+end_src

#+CAPTION: Real-time inverse Fourier Transform
#+begin_src latex
  \begin{tcolorbox}
    \begin{equation*}
      x(t) = \frac{1}{2\;\pi}\int_{-\infty}^{\infty} X(j\Omega)\;e^{j\Omega\;t} dt
    \end{equation*}
  \end{tcolorbox}
#+end_src

**** Real-world frequency
- \Omega expresse in rad/s
- $F=\frac{\Omega}{2\;\pi}$, expressed in Hertz (1/s)
- period $T = \frac{1}{F} = \frac{2\;\pi}{\Omega}$

**** Example

#+BEGIN_SRC octave :exports results :results file
  pkg load signal
  clc; clear all; close all;
  
  s = 5; #sigma
  t = -60:0.1:60;
  x = exp((-t.^2)./(2*s^2));
  # y= x;
  
  O = -2:0.01:2;
  X = s*sqrt(2*pi).*exp((-s^2)/(2)*O.^2)
  
  figure( 1, "visible", "off" )           # Do not open the graphic window in org
  subplot(2,1,1)
  plot(t,x, "linewidth", 3)
  set(gca, "fontsize", 24)
  grid on
  title('Bell Curve')
  xlabel('time s')
  ylabel('x(t)') 
  
  subplot(2,1,2)
  plot(O,X, "linewidth", 3)
  set(gca, "fontsize", 24)
  grid on
  title('Fourier Transform')
  xlabel('Frequency [rad/s]')
  ylabel('X(j\Omega)') 
  
  print -dpng "-S800,400" ./image/w7_gauss-01.png;
  ans = "./image/w7_gauss-01.png";
#+END_SRC

#+results:
[[file:./image/w7_gauss-01.png]]
**** Convolution theorem
#+begin_src latex
  \begin{tcolorbox}
    \begin{equation*}
      Y(j\;\Omega) = X(j\Omega)\;H(j\Omega) 
    \end{equation*}
  \end{tcolorbox}
#+end_src

**** Prototypical Bandlimited Functions

#+BEGIN_SRC octave :exports results :results file
  pkg load signal
  Omega_N=40;            # cutoff frequency
  Omega_B=2*Omega_N;     # passpand
  O=-200:1/100:200;        # frequency vector
  x=rectpuls(O,Omega_B); # generating square wave
  
  figure( 1, "visible", "off" )               # Do not open the graphic window in org
  
  plot(O, x, "linewidth", 3 );
  set(gca, "fontsize", 24)
  title('Prototypical bandlimited function');
  
  axis("nolabel");
  axis([-250 250 -0.4 1.2])
  grid off;
  text(50      ,  -0.2, '\fontsize{24}\it\Omega_N   ',  "color",  "red",  "interpreter",  "tex",  "horizontalalignment",  "center");
  text(-40     ,  -0.2, '\fontsize{24}-\it\Omega_N  ',  "color",  "red",  "interpreter",  "tex",  "horizontalalignment",  "center");
  text(-60      ,  1 , '\fontsize{24}\it{G} ',  "color",  "red",  "interpreter",  "tex",  "horizontalalignment",  "center");
                                  # Org-Mode specific setting
  print -dpng "-S800,200" ./image/w7_bandlimited.png;
  ans = "./image/w7_bandlimited.png";
#+END_SRC

#+results:
[[file:./image/w7_bandlimited.png]]

#+begin_src latex
  \begin{equation*}
    \Phi(j\;\Omega) = G \; rect(\frac{\Omega}{2\;\Omega_N})
  \end{equation*}
#+end_src

The time domain function can be determinded by means of its *Inverse Fourier Transform*

#+begin_src latex
  \begin{align*}
      \phi(t) &= \frac{1}{2\;\pi} \int_{-\infty}^{\infty} \Phi(j\Omega) e^{j\Omega\;t}d\Omega \\
                &= G \frac{\Omega_N}{\pi} sinc(\frac{\Omega_N}{\pi}\;t)
    \end{align*}
#+end_src

The time domain function is up to a scaling, one of these sinc functions. We
will normalize this sinc function, so that the area is equal to $2\pi$ in the
Frequency Domain. Then the inverse continuous time Fourier Transform will have a
maxmimum of 1 at the origin.

#+ATTR_LATEX: :options [leftmargin=5cm,labelwidth=4.7cm,itemindent=-2pt]
- normalization :: $G = \frac{\pi}{\Omega_n}$
- totoal bandwith :: $\Omega_B = 2\;\Omega_N$
- define  :: $T_s = \frac{2\;\pi}{\Omega_B} = \frac{\pi}{\Omega_N}$

This leads to the normalized prototypical bandlimted function:

#+begin_src latex
  \begin{tcolorbox}[colback=red!5!white,colframe=red!75!black,title=Frequency Domain]
  \begin{equation*}
    \Phi(j\;\Omega) = \frac{\pi}{\Omega_N} \; rect\left(\frac{\Omega}{2\;\Omega_N}\right)
  \end{equation*}
  \end{tcolorbox}
#+end_src

#+begin_src latex
  \begin{tcolorbox}[colback=red!5!white,colframe=red!75!black,title=Time Domain]
  \begin{equation*}
      \phi(t) = sinc\left(\frac{t}{T_s}\right)
    \end{equation*}
    \end{tcolorbox}
#+end_src


*** TODO Plot Normalized prototypicale bandlimited function

** Interpolation
#+ATTR_LATEX: :options [leftmargin=5cm,labelwidth=4.7cm,itemindent=-2pt]
- Main Task :: $x[n] \Rightarrow x(t)$
- Gaps :: fill the gaps between samples

*** Interpolation requirements
- decide on $T_s$
- make sure $x(nT_s) = x[n]$
- make sure x(t) is smooth
*** Why smoothness
- jumps (1st order discontinuities) would require the signal to move "faster than light"
- 2nd order discontinuities would require infinite acceleration
- the interpolation should be infinitely differentiable
- "natural" solution: polynomial interpolation
*** Polynomial interpolation
+ N points $\Rightarrow$ polynomial of degree (N-1)
+ $p(t) = a_0 + a_1t +a_2t^2 a ... + a_{N-1} t^{(N-1)}$
+ "naive" approach

  #+begin_src latex
    \begin{equation*}
        \begin{cases}
          p(0)        &= x[0]  \\
          p(T_s)      &= x[1]  \\
          p(2T_s)     &= x[2]  \\
          ......               \\
          p((N-1)T_s) &= x[N-1]
        \end{cases}
    \end{equation*}
  #+end_src

Without loss of generality:
- consider a symmetric interval $I_N = [-N...N]$
- set $T_s = 1$

  #+begin_src latex
    \begin{equation*}
        \begin{cases}
          p(-N)   &= x[-N]   \\
          p(-N+1) &= x[-N+1] \\
          ......             \\
          p(0)    &= x[0]    \\
          p(N)    &= x[N]
        \end{cases}
    \end{equation*}
  #+end_src

*** Lagrange interpolation
The natural solution to this interpolation problem is given by Lagrange interpolation
- $P_N:$ space of degree-2N polynominals over I_N
- a basis for P_N is the family of 2N + 1 Lagrange polynominals

  #+begin_src latex
    \begin{equation*}
      L_n^{(N)}(t) = \prod_{k=-N}^{N} \frac{t-k}{n-k} \text{ for   } M = -N \text{,...,}N
    \end{equation*}
  #+end_src

  The formula:
  #+begin_src latex
    \begin{tcolorbox}
      \begin{equation*}
        p(t) = \sum_{n=-N}^N x[n]L_n^{(N)}(t)
      \end{equation*}
    \end{tcolorbox}
  #+end_src
  

The Lagrange interpolation is the sought-after polynominal interpolation:
- polynominal of degree 2N through 2N+1 points is unique
- the Lagrangian interpolator satisfies
  #+begin_src latex
    \begin{equation*}
      p(N)   = x[N] \text{ for } -N \le M \le N
    \end{equation*}
  #+end_src

  since
 #+begin_src latex
   \begin{equation*}
     L_n^{(N)}(N) =
       \begin{cases}
         1   \text{ if } M = N   \\
         0   \text{ if } M \ne N \\
       \end{cases}
       -N \le M \text{, } N \le N \\
   \end{equation*}
  #+end_src



#+ATTR_LATEX: :options [leftmargin=5cm,labelwidth=4.7cm,itemindent=-2pt]
- key property :: maximmally smooth (infinitely many continuous derivatives)
- drawback :: interpolation "bricks" depend on N
  

*** Sinc interpolation formula

A remarkable result:

#+begin_src latex
  \begin{equation*}
    \lim\limits_{N \rightarrow \infty}{L_n^{(N)}(t)} = sinc(t-n)
  \end{equation*}
#+end_src

In the limit, local and global interpolation are the same! 

#+begin_src latex
  \begin{tcolorbox}
    \begin{equation*}
      x(t) = \sum_{n=-N}^N x[n]sinc\left(\frac{t-nT_s}{T_s}\right)
    \end{equation*}
  \end{tcolorbox}
#+end_src

*** Octave Interpolation Overview
- Octave manual :: Chapter 29.1 One-dimensional Interpolation

#+BEGIN_SRC octave :exports results :results file
  pkg load signal
  clc; clear all; close all;
  
  n=-2:1:2
  nf=-2:0.01:2
  y=[1,2,1,2,-1]
  
  figure( 1, "visible", "off" )           # Do not open the graphic window in org
  
  subplot(2,3,1)
  yp=interp1(n,y,nf,"nearest");
  stem(n,y, "linewidth", 3, "filled")
  hold on;
  plot(nf,yp, "linewidth", 3)
  set(gca, "fontsize", 24)
  axis([-3, 3, -1.5, 2.5]);
  xlabel("nearest")
  grid on
  
  subplot(2,3,2)
  yp=interp1(n,y,nf,"previous");
  stem(n,y, "linewidth", 3, "filled")
  hold on;
  plot(nf,yp, "linewidth", 3)
  set(gca, "fontsize", 24)
  axis([-3, 3, -1.5, 2.5]);
  xlabel("previous")
  grid on
  
  subplot(2,3,3)
  yp=interp1(n,y,nf,"next");
  stem(n,y, "linewidth", 3, "filled")
  hold on;
  plot(nf,yp, "linewidth", 3)
  set(gca, "fontsize", 24)
  axis([-3, 3, -1.5, 2.5]);
  xlabel("next")
  grid on
  
  subplot(2,3,4)
  yp=interp1(n,y,nf,"linear");
  stem(n,y, "linewidth", 3, "filled")
  hold on;
  plot(nf,yp, "linewidth", 3)
  set(gca, "fontsize", 24)
  axis([-3, 3, -1.5, 2.5]);
  xlabel("linear")
  grid on
  
  subplot(2,3,5)
  yp=interp1(n,y,nf,"pchip");
  stem(n,y, "linewidth", 3, "filled")
  hold on;
  plot(nf,yp, "linewidth", 3)
  set(gca, "fontsize", 24)
  axis([-3, 3, -1.5, 2.5]);
  xlabel("cubic / pchip")
  grid on
  
  subplot(2,3,6)
  yp=interp1(n,y,nf,"spline");
  stem(n,y, "linewidth", 3, "filled")
  hold on;
  plot(nf,yp, "linewidth", 3)
  set(gca, "fontsize", 24)
  axis([-3, 3, -1.5, 2.5]);
  xlabel("spline")
  grid on
  
  print -dpng "-S800,300" ./image/w7_interp1_overview.png;
  ans = "./image/w7_interp1_overview.png";
#+END_SRC

#+results:
[[file:./image/w7_interp1_overview.png]]


#+begin_src latex
  \begin{equation*}
    x(t) \sum_{n=-N}^N x[n]i_c(t-n)
    \end{equation*}
#+end_src

** Sampling of bandlimited functions
*** The spectrum of interpolated signals
***** Sinc interpolation
the ingredients:
- discrete-time signal $x[n] \text{, n} \in \mathbb{Z} \text{ (with DTFT } X(e^{j\omega})\text{)}$
- interpolation interval $T_s$
- the sinc function (properly scaled to have zero crossing at multiple of $T_s$ the result
- a smooth, contious-time signal $x(t) \text{, } t \in \mathbb{R}$
  
What does the spectrum of x(t) look like?
***** Key Facts about the sinc

| $\phi(t) = sinc\left(\frac{t}{T_s}\right)$ | $\longleftrightarrow$ | $\Phi(j\Omega) = \frac{\pi}{\Omega_N} rect \left(\frac{\Omega}{2\Omega_N}\right)$ |
| $T_s = \frac{\pi}{\Omega_n}$               |                       | $\Omega_N = \frac{\pi}{T_s}$                                                      |


#+begin_src octave :exports results :results file
   pkg load signal
   TS = 1/2;
   Omega_N = pi/TS;
   t = [-4:1/100:4];
   omega = [-30:1/10:30]

  # Algorithm --------------------------------------------------------------
   phy = sinc(t./TS);                                   # sinc
   PHY = pi/Omega_N .* rectpuls(omega,2*Omega_N);       # Rectpuls


   figure( 1, "visible", "off" )               # Do not open the graphic window in org

   subplot(2,1,1)
   plot(t, phy, "linewidth", 3);
   set(gca, "fontsize", 24, 'YTick', -0.5:0.25:1.2, 'XTick', -4:0.5:4)
   text(0.5      , -0.4 , '\fontsize{16}\it{T_s} ',  "color",  "red",  "interpreter",  "tex",  "horizontalalignment",  "center");
   title('T_s = 0.5s / Fs = 2Hz')
   xlabel('time [sec]');
   ylabel('\phi(t)');
   axis([-4 4 -0.5 1.2]);
   grid on

   subplot(2,1,2)
   # Plot 1 -----------------------------------------------------------------
   plot(omega,PHY, "linewidth", 3);
   axis([-30 30 0 1]);
   set(gca,'XTick',-(10*Omega_N):Omega_N:(10*Omega_N));
   set(gca,'XTickLabel',{'-\Omega_N','0','\Omega_N','2\Omega_N','3\Omega_N','4\Omega_N','-4\Omega_N','-3\Omega_N','-2\Omega_N'})
   xlabel('\Omega [rad/sec]')
   set(gca,'YTick',0:0.5:1);
   ylabel('\Phi(j\Omega)')
   text(-6.5      , 0.55 , '\fontsize{16}\it{\pi/\Omega_N} ',  "color",  "red",  "interpreter",  "tex",  "horizontalalignment",  "right");
   title('\Omega_N = pi/T_s = 6.3');
   set(gca, "fontsize", 24);
   grid on ;


   print -dpng "-S800,400" ./image/w7_key_facts_sinc.png;
   ans = "./image/w7_key_facts_sinc.png";
#+end_src

#+results:
[[file:./image/w7_key_facts_sinc.png]]

***** Sinc interpolation

#+begin_src latex 
  \begin{equation*}
  x(t) = \sum_{n=-\infty}^{\infty} x[n] sinc\left(\frac{t-nT_s}{T_s}\right)
  \end{equation*}
#+end_src

***** Spectral representation (I)


#+begin_src latex
  \begin{align*}
    X(j\Omega) &= \int_{-\infty}^{\infty} x(t) \; e^{-j\Omega t}dt\\
               &= \int_{-\infty}^{\infty} \sum_{n=-\infty}^{\infty} x[n] sinc\left(\frac{t-nT_s}{T_s}\right) \; e^{-j\Omega t}dt\\
               &= \sum_{n=-\infty}^{\infty} x[n]  \int_{-\infty}^{\infty} sinc\left(\frac{\tikzmarkin{w7-a}(0.1,0.1)(-0.1,0.3)t-nT_s}{T_s}\tikzmarkend{w7-a}\right) \; e^{-j\Omega t}dt\\
               &= \sum_{n=-\infty}^{\infty} x[n]  \left(\frac{\pi}{\Omega_N}\right) rect\left(\frac{\Omega}{2 \Omega_N}\right) \; \tikzmarkin{w7-b}(0.1,-0.2)(-0.1,0.5)e^{-j n T_s \Omega}\tikzmarkend{w7-b}\\
\end{align*}
               #+end_src

***** Spectral representation (II)
Let's analyse the formula
#+begin_src latex
  \begin{align*}
    X(j\Omega) &= \sum_{n=-\infty}^{\infty} x[n]  \left(\frac{\pi}{\Omega_N}\right) rect\left(\frac{\Omega}{2 \Omega_N}\right) \; e^{-j n T_s \Omega}\\
               &=  \left(\frac{\pi}{\Omega_N}\right) rect\left(\frac{\Omega}{2 \Omega_N}\right) \; \sum_{n=-\infty}^{\infty} x[n]  e^{-j (\pi / \Omega_N) \Omega \; n}\\
    \\  
               & =
                 \left\{
                    \begin{array}{ll}
                       \left(\frac{\pi}{\Omega_N} \right) X(e^{j\pi(\Omega/\Omega_N)})  & |\Omega| \leq \Omega_N   \\
                        0   & otherwise \\
                    \end{array}
                 \right.
  \end{align*} 
#+end_src

The DTFT is periodic and the periodic is 
#+begin_src latex
  \begin{align*}
    \sum_{n=-\infty}^{\infty} x[n]  e^{-j (\pi / \Omega_N) \Omega \; n}
    &= \sum_{n=-\infty}^{\infty} x[n]  e^{-j \omega n}
      \text{, with } \omega = 2\cdot \Omega_N
  \end{align*} 
#+end_src

#+ATTR_LATEX: :options [logo=\bcbook, couleur=yellow!10, barre=snake, arrondi=0.1]{Spectrum of Sinc-Sampling}
#+BEGIN_bclogo
The spectrum of $x(t)$ is equal to the scaled version of the DTFT of the
sequence between $- \Omega_N$ and $\Omega_N$.
#+END_bclogo

****** TODO COMMENT Not Working yet

#+BEGIN_SRC octave :exports results :results file
  pkg load signal
  clc; clear all; close all;

  n = -32:0.01:32;
  wc = 0.01
  N = length(n);              % length of test data vector
  x = sinc(wc.*n)./(pi./n);

  for k = 1:N
    Y(k) = 0;
    for m = 1:N
         Y(k) = Y(k)+(x(m)*exp((-1j)*2*pi*(m-1)*(k-1)/N));
    end
  end

  figure( 1, "visible", "off" )           # Do not open the graphic window in org
  subplot(2,1,1);
  plot(n,x, "linewidth", 3)
  set(gca, "fontsize", 24)
  grid on
  title('Sinc Function')
  xlabel('n')
  ylabel('x[n]') 

  subplot(2,1,2);
  stem(n,fftshift(abs(Y)), "linewidth", 3)
  set(gca, "fontsize", 24)
  grid on
  title('DFT Sinc Function')
  xlabel('n')
  ylabel('x[n]') 



  print -dpng "-S800,400" ./image/w7_spectrum_int_signal-01.png;
  ans = "./image/w7_spectrum_int_signal-01.png";
#+END_SRC

#+results:



Pick interpolation period T_s:
- $X(j\Omega)$ is $\Omega_N-bandlimited$, with $\Omega_N = \pi/T_s$
- fast interpolation ($\T_s$ small) $\Rightarrow$ wider spectrum
- slow interpolation ($\T_s$ large) $\Rightarrow$ narrower spectrum

*** The space of bandlimited functions

*Claims:*
 - the space of $\Omega_N-bandlimited$ functions is a Hilbert space
 - the functions $\phi^{(n)}(t) = sinc((t-n)$, with n $\in \mathbb{Z}$  form a bais for the space
 - if $x(t)$ is $\pi-BL$ the sequence x[n] = x(n), with n $\in \mathbb{Z}$, is a
   sufficient representation, i.e. we can recunstruct x(t) from x[n]


The space $\pi-BL$
- is a a vector space because $\pi-BL \subset L_2(\mathbb{R})$
- inner product is standard inner product in $L_2(\mathbb{R})$
- completeness... that's more delicate

#+ATTR_LATEX: :options [logo=\bcbook, couleur=yellow!10, barre=snake, arrondi=0.1]{Basis for $\pi-BL$}
#+BEGIN_bclogo
The sync function $sinc\left(\frac{t - n T_s}{T_s}\right)$ is an orthornormal basis for the $\pi - BL$ space.
#+END_bclogo


Inner product:
#+begin_src latex
  \begin{equation*}
    \langle x(t),y(t)\rangle = \int_{-\infty}^{\infty} x * (t)y(t)dt
  \end{equation*}
#+end_src

Convolution:
#+begin_src latex
  \begin{equation*}
    (x * y)(t) = \langle x * (\tau),y(t-\tau)\rangle
  \end{equation*}
#+end_src

A basis for the $\pi-BL$ space
#+begin_src latex
  \begin{equation*}
    \phi^{(M)}(t) = sinc(t-n) \text{, for } M \in \mathbb{Z}
  \end{equation*}
#+end_src

#+begin_src latex
  \begin{equation*}
    FT{sinc(t)} = rect\left(\frac{\Omega}{2\pi}\right)
  \end{equation*}
#+end_src

#+begin_src latex
  \begin{equation*}
    (sinc * sinc)(m-n) = \left\{
            \begin{array}{ll}
              1   \text{ for } m=n   \\
              0   \text{ otherwise }\\
            \end{array}
          \right.
  \end{equation*}
#+end_src

*** The sampling Theorem
***** Sampling as a basis expansion
To see sampling as an orthonormal expansion, we take our sample of orthonormal
vectors $\phi^(n)$, taking a product with x and we look what comes out.

#+begin_src latex
  \begin{tcolorbox}[colback=blue!5!white,colframe=blue!75!black,title=Analysis Formula]
    \begin{equation*}
      x[n] = \langle sinc\left(\frac{t-nT_s}{T_s}\right),x(t) \rangle = T_s x(nT_s)
    \end{equation*}
  \end{tcolorbox}
 #+end_src

 #+begin_src latex
   \begin{tcolorbox}[colback=red!5!white,colframe=red!75!black,title=Synthesis Formula]
      \begin{equation*}
         x(t) =  \frac{1}{T_s} \sum_{n=-\infty}^{\infty} x[n] sinc\left(\frac{t-nT_s}{T_s}\right)
      \end{equation*}
   \end{tcolorbox}
 #+end_src

 - the space of $\Omega_n-bandlimited$ functions is a Hilbert space
 - set $T_s = \pi/\Omega_N$
 - the functions $\phi^{(n)}(t) = sinc((t-nT_s)/T_s)$ form a bais for the space
 - for any $x(t) \in \Omega_N-BL$ the coefficients in the sinc basis are the (scaled) samples $T_s x(nT_s)$

#+ATTR_LATEX: :options [logo=\bcbook, couleur=yellow!10, barre=snake, arrondi=0.1]{Corolllary}
#+BEGIN_bclogo
for any $x(t) \in \Omega_N-BL$, a sufficient representation is the sequence $x[n] = x(nT_s)$
#+END_bclogo


#+ATTR_LATEX: :options [logo=\bcbook, couleur=yellow!10, barre=snake, arrondi=0.1]{The sampling theorem in Hertz}
#+BEGIN_bclogo
Any signal x(t) bandlimited to $F_N$ Hz can be sampled with no loss of information using a sampling frequency $F_s \geq 2F_N$ (i.e. sampling period
$T_s \leq 1/2\;F_N$
#+END_bclogo

** Sampling of none bandlimited functions
*** Raw Sampling
Raw sampling is when we don't care about first taking the inner product with the
sinc function. So we just take x(t) and every T_s seconds, we take a sample.\\

The continous-time complex exponential
#+begin_src latex 
\begin{equation*}
 x(t) = e^{j \Omega_0 t}
\end{equation*}
#+end_src
- always periodic, period $T = \frac{2\pi}{\Omega_0}$
- all angualr speed are allowed
- $FT \left\{e^{j \Omega_0 t} \right\} = 2\pi\delta(\Omega - \Omega_0)$
- bandlimited to $\Omega_0$

#+ATTR_LATEX: :placement [ht] :align  p{4cm} p{4cm} p{4cm}
#+CAPTION: Aliasing
| <20>                                     | <20>                            | <20>                                                       |
|------------------------------------------+---------------------------------+------------------------------------------------------------|
| \myheadcolor\mytextcolor sampling period | \mytextcolor digital frequency  | \mytextcolor {$\hat{x}$}                                                |
| $T_s < \pi/\Omega_0$                     | 0 < \omega_o < \pi              | e^{j\Omega_0}                                              |
| $\pi/\Omega_0 < T_s < 2\pi/\Omega_0$     | \pi < \omega_0 < 2\pi           | $e^{j\Omega_1}\text{: } \Omega_1 = \Omega_0 -2\pi/T_s$     |
| T_s > 2\pi/\Omega_0                      | \omega_0 > 2\pi                 | $e^{j\Omega_2}\text{: } \Omega_2 = \Omega_0 mod(2\pi/T_s)$ |
|------------------------------------------+---------------------------------+------------------------------------------------------------|

*** Sinusoidal Aliasing

#+begin_src latex
\begin{align*}
  x(t) &= cos(2\pi F_ot ) \\
  x[n] &= x(nT_s) = cos(\omega_0 n) \\
\end{align*}
#+end_src
with
#+begin_src latex
\begin{align*}
  F_s      &= \frac{1}{T_s} \\
  \omega_o &=  2\pi(\frac{F_0}{F_s})\\
\end{align*}
#+end_src


**** Aliasing: Sampling a Sinusoid
#+begin_src octave :exports results :results file
  w=1
  T = [0:1/1000:w];     %1000Hz sampling frequency
  A = cos(2*pi*3*T);
  
  t100 = [0:1/100:w];      %20Hz sampling
  a100 = cos(2*pi*3*t100);  %3Hz sine wave
  
  t10 = [0:1/10:w];      %20Hz sampling
  a10 = cos(2*pi*3*t10);  %3Hz sine wave
  
  t6 = [0:1/6:w];      %20Hz sampling
  a6 = cos(2*pi*3*t6);  %3Hz sine wave
  
  t3 = [0:1/3:w];      %20Hz sampling
  a3 = cos(2*pi*3*t3);  %3Hz sine wave
  
  figure( 1, "visible", "off" )               # Do not open the graphic window in org
  subplot(2,2,1);
  plot(T, A, 'b', "linewidth", 1);
  set(gca, "fontsize", 24, 'XTick', 0:0.25:1, 'YTick', -2:1:2);
  title("F = 3Hz / Fs = 100Hz");
  xlabel('time [s]');
  axis([0 w -1.2 1.2]);
  grid 'on';
  hold on;
  plot(t100, a100, "color","r", 'o', "markersize", 5, "linewidth", 3 );
  
  subplot(2,2,2);
  plot(T, A, 'b', "linewidth", 1);
  set(gca, "fontsize", 24, 'XTick', 0:0.25:1, 'YTick', -2:1:2)
  title("F = 3Hz / Fs = 10Hz");
  xlabel('time [s]');
  axis([0 w -1.2 1.2]);
  grid on;
  hold on;
  plot(t10, a10, "color","r", 'o', "markersize", 5, "linewidth", 3 );
  
  subplot(2,2,3);
  plot(T, A, 'b', "linewidth", 1);
  set(gca, "fontsize", 24, 'XTick', 0:0.25:1, 'YTick', -2:1:2)
  title("F = 3Hz / Fs = 6Hz");
  xlabel('time [s]');
  axis([0 w -1.2 1.2]);
  grid on;
  hold on;
  plot(t6, a6, "color","r", 'o', "markersize", 5, "linewidth", 3 );
  
  subplot(2,2,4);
  plot(T, A, 'b', "linewidth", 1);
  set(gca, "fontsize", 24, 'XTick', 0:0.25:1, 'YTick', -2:1:2)
  title("F = 3Hz / Fs = 3Hz");
  xlabel('time [s]');
  axis([0 w -1.2 1.2]);
  grid on;
  hold on;
  plot(t3, a3, "color","r", 'o', "markersize", 5, "linewidth", 3 );
  
  print -dpng "-S800,400" ./image/w7_sampling_01.png;
  ans = "./image/w7_sampling_01.png";
#+end_src

#+results:
[[file:./image/w7_sampling_01.png]]

#+begin_src octave :exports results :results file
  w=20
  t = [0:1/2.9:w];      %2.9Hz sampling
  a = cos(2*pi*3*t);  %3Hz sine wave
  
  T = [0:0.001:w];     %1000Hz sampling frequency
  A = cos(2*pi*3*T);
  figure( 1, "visible", "off" )               # Do not open the graphic window in org
  
  
  plot(t, a, "color","r", 'o', "markersize", 5, "linewidth", 3 );
  set(gca, "fontsize", 24, 'YTick', -2:1:2)
  title('F = 2.9Hz / Fs = 3Hz')
  xlabel('time [s]');
  axis([0 w -1.2 1.2]);
  grid on
  hold on;
  plot(T, A, 'b', "linewidth", 0.5);
  
  print -dpng "-S800,200" ./image/w7_sampling.png;
  ans = "./image/w7_sampling.png";
#+end_src

#+results:
[[file:./image/w7_sampling.png]]

*** Aliasing for arbitrary spectra
A contiuous time signal $x_c$ sampled every $T_s$ seconds gives a sequence
x[n]. Which is equal to the contious time signals at multiples of the sampling
intervals $T_s$.
- $x_c(t) \Rightarrow x[n] =x_c(nT_s)$
In Fourier Transform domain we have a spectra of the continuous time signal
$X_c(j\Omega)$. And at the output we have a discrete time Fourier Transform of
the sequence $X(j\omega)$. What is that going to be in genaral? And how is it
going to be related to the input spectrum?
- $X(j\Omega) \Rightarrow X(j\omega) = ?$

The key idea:
- pick $T_s$ and set $\Omega_N = \pi/T_s$
- pick $\Omega_= < \Omega_N$
  
#+begin_src latex
\begin{align*}
  e^{j\Omega_0 t} &\rightarrow e^{j\Omega_0 T_s n} \\
  e^{j(\Omega_0 + 2\Omega_N) t} &\rightarrow e^{j(\Omega_0 + 2\Omega_N) T_s n} \text{, add } 2 \Omega_N \\
  e^{j(\Omega_0 + 2\Omega_N) t} &\rightarrow e^{j(\Omega_0 T_s n + 2 \Omega_N T_s n)} \text{, expand this product } \\ 
  e^{j(\Omega_0 + 2\Omega_N) t} &\rightarrow e^{j(\Omega_0 T_s n + \frac{2 \pi}{T_s}T_s n)}  \\
  e^{j(\Omega_0 + 2\Omega_N) t} &\rightarrow e^{j(\Omega_0 T_s n + 2\pi n)}  \text{,  } e^{j 2 \pi n} \text{ is equal to one}\\
  e^{j(\Omega_0 + 2\Omega_N) t} &\rightarrow e^{j\Omega_0 T_s n }  \text{,  the same discrete time sequence as before}\\
\end{align*}
#+end_src

So we do not see the higher frequency complex exponential, it simply looks like the lower frequency exponential $\Omega_0$.

#+ATTR_LATEX: :options [logo=\bcbook, couleur=yellow!10, barre=snake, arrondi=0.1]{Aliasing}
#+BEGIN_bclogo
So in general, if we have two frequencies sampled, the higher frequency is
aliased back onto the lower frequency and we simply see the sum of these two.
#+END_bclogo

***** Spectrum of raw-sampled signals

- start with the inverse Fourier Transform
  #+begin_src latex
  \begin{equation*}
    x[n] = x_c(nT_s) = \frac{1}{2\pi}\int_{-\infty}^{\infty} X_c(j\Omega)e^{j\Omega M T_s}d\Omega
  \end{equation*}
  #+end_src
- frequencies $2\Omega_N$ apart will be aliased, so split the integration interval
  #+begin_src latex
  \begin{equation*}
    x[n] = \frac{1}{2\pi} \sum_{k=-\infty}^{\infty} \int_{(2k-1)\Omega_N}^{(2k+1)\Omega_N} X_c(j\Omega)e^{j\Omega M T_s}d\Omega
  \end{equation*}
  #+end_src

- with a change of variable and using $e^{j (\Omega + 2k \Omega_N) T_s M} = e^{j \Omega T_s M}$  
#+begin_src latex
\begin{equation*}
  x[n] = \frac{1}{2\pi} \sum_{k=-\infty}^{\infty} \int_{-\Omega T_s M}^{\Omega T_s M} X_c(j(\Omega - 2k\Omega_N)e^{j\Omega M T_s}d\Omega 
\end{equation*}
  #+end_src

- interchange summation and integral
#+begin_src latex
\begin{equation*}
  x[n]  = \frac{1}{2\pi} \int_{-\Omega T_s M}^{\Omega T_s M} \left[ \sum_{k=-\infty}^{\infty} X_c(j(\Omega - 2k\Omega_N) \right] e^{j\Omega M T_s}d\Omega
\end{equation*}
  #+end_src
  
- periodization of the spectrum; define
#+begin_src latex
\begin{equation*}
   \tilde{X}_c (j \Omega) = \sum_{k=-\infty}^{\infty} X_c(j(\Omega - 2k \Omega_N)
\end{equation*}
  #+end_src

- so that
#+begin_src latex
\begin{equation*}
 x[n] = \frac{1}{2\pi} \int_{-\Omega T_s M}^{\Omega T_s M} \tilde{X}_x(j\Omega) e^{j\Omega M T_s}d\Omega
\end{equation*}
  #+end_src

- set $\omega = \Omega T_s$
#+begin_src latex
\begin{align*}
  x[n] &= \frac{1}{2\pi} \int_{-\pi}^{\pi} \frac{1}{T_s} \tilde{X}_c(j\frac{\omega}{T_s}) e^{j\omega M}d\omega \\
       &= IDTFT \left\{ \frac{1}{T_s} \tilde{X}_c(j\frac{\omega}{T_s}) \right\} \\
  X(e^{j\omega})  &= \frac{1}{T_s} \sum_{k=-\infty}^{\infty} \tilde{X}_c \left(j\frac{\omega}{T_s} - j\frac{2\pi k}{T_s}\right) \\
\end{align*}
#+end_src

#+begin_src latex
\begin{equation*}
    X(e^{j\omega})  = \frac{1}{T_s} \sum_{k=-\infty}^{\infty} \tilde{X}_c \left( j\frac{\omega}{T_s} - j\frac{2\pi k}{T_s} \right) \\
\end{equation*}
#+end_src
***** TODO Example: signal bandlimited to \Omega_0 and \Omega_N > \Omega_0
***** TODO Example: signal bandlimited to \Omega_0 and \Omega_N = \Omega_0
***** TODO Example: signal bandlimited to \Omega_0 and \Omega_N < \Omega_0
***** TODO Example: non-bandlimited signal

*** Sampling strategies

given a sampling period $T_s$
- if the signal is bandlimited to $\pi/T_s$ or less, raw sampling is fine
  i.e. equivalent to sinc sampling up to scaling factor $T_s$.
- if the signal is not bandlimited, two choices:
  - bandlimit via lowpass filter in the /continuous-time domain/ before sampling i.e. sinc sampling
  - or raw sample the signal an incur aliasing
- aliasing sounds horrible, so usualle we choose to bandlimit in continuous time

***** Sinc Sampling and Interpolation

#+begin_src latex
\begin{align*}
  \hat{X}[n] &= \langle sinc\left(\frac{t-nT_s}{T_s}\right),x(t) \rangle = (sinc T_s * x)(n T_s) \\
  \hat{X}[n] &= \sum_n x[n] \;sinc\left(\frac{t - n T_s}{T_s}\right)
 \end{align*}
#+end_src

[[file:./drawing/sinc_sampling.png]]

** Quantization
*** Stochastic signal processing
**** Terminology ( from [[http://www.dspguide.com/ch2.htm][W.Smith]] )
#+ATTR_LATEX: :options [leftmargin=3cm,labelwidth=2.7cm,itemindent=-2pt]
 - Mean, Average ::
  #+begin_src latex
     \begin{equation*}
      \mu = \frac{1}{N} \sum_{i=0}^{N-1} x_i = (x_0 + x_1 + x_2 + ... + x_{N-1})/N
     \end{equation*}
   #+end_src
  In electronics, the mean is commonly called the *DC* (direct current)
  value. Likewise, *AC* (alternationg current) refers to how the signal fluctuates
  around the mean value. For simple repetitive waveform, its excursion can be
  described by its peak-to peak value. If the signal has a random nature, a more
  generalized method must be used.

 - Standard Deviation ::
   #+begin_src latex
     \begin{align*}
       \sigma &= \sqrt{\frac{1}{N-1} \sum_{i=0}^{N-1}(x_i - \mu)^2)} \\
              &= \sqrt{(x_0 - \mu)^2 + (x_1 - \mu)^2 + ... + (x_{N-1} - \mu)^2 /(N-1)}\\
     \end{align*} 
   #+end_src
   $|x_i - \mu|$ describes how far the $i^{th}$ sample *deviates* (differs) from
   the mean. The *average deviation* of a signal is found by summing the deviations
   of all the individual samples, and then dividing by the number of samples
   N. We take the absolute value of each deviation before summation; otherwise
   the positive and the negative termss would average to zero.

   The *standard deviation* is similar to the average deviation, except the
   averaging is done with power instead of amplitude.

   The standard deviation is a measure of how far the signal fluctuates from the
   mean.
 - Variance ::
   #+begin_src latex
    \begin{equation*}
      \sigma^2 = \frac{1}{N-1} \sum_{i=0}^{N-1}(x_i - \mu)^2) 
    \end{equation*} 
   #+end_src
   The variance represents the power of signal fluctuation from the mean.
 - RMS Root Mean Square ::
   The standard deviation measures only the AC portion of a signal, while rms
   value measures both the AC and DC components. If a signal has no DC component,
   its rms value is identical to its standard deviation.
 - SNR Signal to Noise Ratio ::
   #+begin_src latex
     \begin{equation*}
     snr = \frac{mean}{standard deviation} = \frac{\mu}{\sigma} = \frac{\frac{1}{N} \sum_{i=0}^{N-1} x_i}{\sqrt{\frac{1}{N-1} \sum_{i=0}^{N-1}(x_i - \mu)^2)}}
     \end{equation*}
   #+end_src
 - CV Coefficent Variation ::
   #+begin_src latex
     \begin{equation*}
       CV = \frac{standard \text{ } deviation}{mean} \times 100 = \frac{\sqrt{\frac{1}{N-1} \sum_{i=0}^{N-1}(x_i - \mu)^2)}}{\frac{1}{N} \sum_{i=0}^{N-1} x_i} \times 100
     \end{equation*}
   #+end_src
 - Probability Density Function PDF :: The probability density function is a
   measure of the likelihood of a particular value occuring in some function.
   - PDF values are never negative $f(x) \geq 0$
   - The sum of all the PDF values is one: $\int_{- \infty}^{\infty} f(x) dx = 1$
   - Mean: $\mu_x = \int_{- \infty}^{\infty} x \cdot f(x) dx$
   - Variance: $\mu_x^2 = \int_{- \infty}^{\infty} (x-\mu)^2 \cdot f(x) dx = \int_{- \infty}^{\infty} x^2 \cdot p(x)dx - \mu_x^2$
   
**** TODO Deterministic vs. stochastic
**** A simple discrete-time random signal generator

For each new sample, toss a fair coin:

#+begin_src latex
  \begin{equation*}
    x[n] = \left\{
            \begin{array}{ll}
              +1  &\text{if the outcome of the n-th toss is head}\\
              -1  &\text{if the outcome of the n-th toss is tail}\\
            \end{array}
          \right.
  \end{equation*}
#+end_src

- each sample is independet from all others
- each sample value has 50% probability
#+begin_src octave :exports results :results file
  N = 16;  # rows
  M = 6;   # columns
  x = rand(N,M);
  y = zeros(N,M);
  for i=1:N
    for j=1:M
      if (10*x(i,j) > 5)
        y(i,j) = 1
      else
        y(i,j) = -1
      end
    end
  end
  figure( 1, "visible", "off" )               # Do not open the graphic window in org
  row = 2;
  column = 3;
  for p=1:(row*column)
    subplot(row, column, p)
    stem(1:N,y(:,p), "linewidth", 2, "filled")
    axis([0 m+1 -1.2 1.2]);
    set(gca,'XTick',0:16:32,'YTick',-2:1:2,'fontangle','italic','fontsize', 24)
  
  end
  print -dpng "-S800,350" ./image/w7_stoch-01.png;
  ans = "./image/w7_stoch-01.png";
#+end_src

#+results:
[[file:./image/w7_stoch-01.png]]

- every time we turn on the generator we obtain a different /realization/ of the signal
- we know the "mechanics" behind each instance
- but how can we analyze a random signal?

**** Spectral Properties
- let's try with the DFT of a finite set of random samples

#+begin_src octave :exports results :results file
  N = 16;  # rows
  M = 3;   # columns
  x = rand(N,M);
  y = zeros(N,M);
  for i=1:N
    for j=1:M
      if (10*x(i,j) > 5)
        y(i,j) = 1
      else
        y(i,j) = -1
      end
    end
  end
  figure( 1, "visible", "off" )               # Do not open the graphic window in org
  row = 1;
  column = 3;
  for p=1:(row*column)
    subplot(row, column, p)
    stem(1:N,abs(fft(y(:,p))), "linewidth", 2, "filled")
    axis([0 N+1 0 15]);
    set(gca,'XTick',0:16:32,'YTick',0:5:15,'fontangle','italic','fontsize', 24)
  
  end
  print -dpng "-S800,200" ./image/w7_stoch-02.png;
  ans = "./image/w7_stoch-02.png";
#+end_src

#+results:
[[file:./image/w7_stoch-02.png]]

- every time it's a different
- try with more data
#+begin_src octave :exports results :results file
  N =32;  # rows
  M = 3;   # columns
  x = rand(N,M);
  y = zeros(N,M);
  for i=1:N
    for j=1:M
      if (10*x(i,j) > 5)
        y(i,j) = 1
      else
        y(i,j) = -1
      end
    end
  end
  figure( 1, "visible", "off" )               # Do not open the graphic window in org
  row = 1;
  column = 3;
  for p=1:(row*column)
    subplot(row, column, p)
    stem(1:N,abs(fft(y(:,p))), "linewidth", 2, "filled")
    axis([0 N+1 0 15]);
    set(gca,'XTick',0:16:32,'YTick',0:5:15,'fontangle','italic','fontsize', 24)

  end
  print -dpng "-S800,200" ./image/w7_stoch-03.png;
  ans = "./image/w7_stoch-03.png";
#+end_src

#+results:
[[file:./image/w7_stoch-03.png]]

- no clear pattern

**** Averaging
- when faced with random data an intuitive response is to take "averages"
- in probability theory the average is across realizations and it's called
  \textcolor{blue}{Expectation}
- Expectation for the coin-toss signal
  #+begin_src latex
  \begin{tcolorbox}
    \begin{equation*}
        E[x[n]] = -1 \times P[\text{n-th toss is tail}] + 1 \times P[\text{n-th toss is head}] = 0
    \end{equation*}
  \end{tcolorbox}
  #+end_src
  
- so the average value for each sample is zero....
- as a consequence, averaging the DFT will not work
- $E[x[n]] = 0$
- however the signal "moves", so its energy over power must be nonzero
**** TODO Averaging the DFT
**** Energy and power
- the coin-toss signal has infinite energy
#+begin_src latex
\begin{equation*}
  E_x = \sum\limits_{k=-\infty}^{\infty} \vert x[n] \vert^2 = \lim_{N \rightarrow \infty} = \infty
\end{equation*}
#+end_src

- however it has finite power over any interval:
#+begin_src latex
\begin{equation*}
  P_x = \lim_{N \rightarrow \infty} \frac{1}{2N+1} \sum_{n=-N}^{N} \vert x[n] \vert^2 = 1
\end{equation*}
#+end_src
  
**** Averaging the DFT's square magnitude, normalized

- pick an interval length N
- pick an number of iterations M
- run the signal generator M times and obtain M N-point realizations
- compute the DFT of each realizations
- average their square magnitude divided by N

#+begin_src octave :exports results :results file
  figure( 1, "visible", "off" )               # Do not open the graphic window in org

  disp_row = 1;
  disp_column = 3;
  realizations = 0;
  for p=1:(disp_row*disp_column)
    N =16;  # rows
    M = 50*10^p;   # columns
    realizations = M
    x = rand(N,M);
    y = zeros(N,M);
    for i=1:N
      for j=1:M
        if (10*x(i,j) > 5)
          y(i,j) = 1;
        else
          y(i,j) = -1;
        end
      end
    end

    subplot(disp_row, disp_column, p)
    Y = abs(fft(y));
    Q = sum(Y.^2,2)/N/(M+1);

    stem(1:N,Q, "linewidth", 2, "filled")
    axis([0 N+1 0 1.2]);
    xlabel(realizations);
    set(gca,'XTick',0:4:16,'YTick',0:0.2:1.2,'fontangle','italic','fontsize', 24)
    grid on;
  end

  print -dpng "-S800,200" ./image/w7_stoch-05.png;
  ans = "./image/w7_stoch-05.png";
#+end_src

#+results:
[[file:./image/w7_stoch-05.png]]

**** Power spectral density
#+begin_src latex
\begin{tcolorbox}[colback=red!5!white,colframe=red!75!black,title=Power Spectral Density]
\begin{equation*}
  P[k] = E \left[ \left| X_N[k] \right|^2 / N\right]
\end{equation*}
\end{tcolorbox}
#+end_src



+ it looks very much as if P[k] = 1
+ if $\left| X_N[k] \right|^2$ tends to the /energy/ distribution in frequnec....
+ ... $\left| X_N[k] \right|^2/N$ tends to the /power/ distribution (aka *density*) in frequency

  #+ATTR_LATEX: :options [logo=\bcbook, couleur=yellow!10, barre=snake, arrondi=0.1]{PSD}
  #+BEGIN_bclogo
  The frequency-domain representation for stochastic processes is the power
  spectral density: \\
  $P[k] = \left| \frac{1}{N} X_N[k] \right|^2$
  #+END_bclogo

**** Power spectral density: Intuition
- P[k] = 1 means that the power is equally distributed over all frequencies
- i.e. we cannot predict the signal moves "slowly" or "super-fast"
- this is because each sample is independent of each other: we could have a
  realization of all ones or a realization in which the sign changes every other
  sample or anything in between.

**** Filtering a random process
- let's filter the random process with a 2-point Moving Average filter
- y[n] = (x[n] + x[n-1])/2
- what is the power spectral density

- pick an interval length N
- pick an number of iterations M
- run the signal generator M times and obtain M N-point realizations
- filter all M-realization
- compute the DFT of each filtered realizations
- average their square magnitude divided by N

#+begin_src octave :exports results :results file
  figure( 1, "visible", "off" )               # Do not open the graphic window in org

  disp_row = 2;
  disp_column = 2;
  realizations = 0;
  for p=1:(disp_row*disp_column)
    N =32;              # rows
    if(p<3)
      M = 1*10^(p-1);   # columns
    else
      M = 1*10^(p);
    endif
    realizations = M;
    x = rand(N,M);      # Input signals
    y = zeros(N,M);     # output signals, all set to zeors
    for i=1:N
      for j=1:M
        if(i<2)                                    # apply filter only if i > 1
          if (10*x(i,j) > 5)
            y(i,j) = 1;
          else
            y(i,j) = -1;
          endif
        else
          if ((10 * ((x(i,j) + x(i-1,j))/2)) > 5)  # aplly the MA Filter
            y(i,j) = 1;
          else
            y(i,j) = -1;
          endif
        endif
      end
    end

    subplot(disp_row, disp_column, p)
    Y = abs(fft(y));            # The DFT's of the output signals
    Q = (abs(fft(y))).^2/N;     # the square magnitudes divided by N of the signals
    S = sum(Q,2)/(M+1);         # the average 

    stem(1:N,S, "linewidth", 2, "filled")
    axis([0 N+1 0 2]);
    xlabel(realizations);
    set(gca,'XTick',0:4:32,'YTick',0:0.4:2,'fontangle','italic','fontsize', 24)
    
    grid on;
  end

  print -dpng "-S800,400" ./image/w7_stoch-06.png;
  ans = "./image/w7_stoch-06.png";
#+end_src

#+results:
[[file:./image/w7_stoch-06.png]]

The frequency response of the moving average filter
#+begin_src latex
  \begin{equation*}
  H(e^{j\omega}) = \frac{1 - e^{j\omega}}{2} 
  \end{equation*}
#+end_src

whereas the ploted shape is nothing but the square magnitude of the moving
average filter evaluated at the DFT point $\frac{2\pi}{N}k$

#+begin_src octave :exports results :results file
    N = 32;
    M = 5000;
    realizations = M;

    x = rand(N,M);      # Input signals
    y = zeros(N,M);     # output signals, all set to zeors
    for i=1:N
      for j=1:M
        if(i<2)                                    # apply filter only if i > 1
          if (10*x(i,j) > 5)
            y(i,j) = 1;
          else
            y(i,j) = -1;
          endif
        else
          if ((10 * ((x(i,j) + x(i-1,j))/2)) > 5)  # aplly the MA Filter
            y(i,j) = 1;
          else
            y(i,j) = -1;
          endif
        endif
      end

      Y = abs(fft(y));            # The DFT's of the output signals
      Q = (abs(fft(y))).^2/N;     # the square magnitudes divided by N of the signals
      S = sum(Q,2)/(M+1);         # the average 

      figure( 1, "visible", "off" )               # Do not open the graphic window in org
      stem(1:N,S, "linewidth", 2, "filled")
      axis([0 N+1 0 2]);
      xlabel(realizations);
      set(gca,'XTick',0:4:32,'YTick',0:0.4:2,'fontangle','italic','fontsize', 24)
      legend('|(i-e^{j(2\pi/N)k})/2^2|');
      grid on;
    end

    print -dpng "-S800,200" ./image/w7_stoch-07.png;
    ans = "./image/w7_stoch-07.png";
#+end_src

#+results:
[[file:./image/w7_stoch-07.png]]

**** Stochaistic signal processing
- a stochastic process is characterized in frequency by its power spectral density (PSD)
- it can be shown (see text book) that the PSD is the DTFT of the
  autocorrelation of the process:
  #+begin_src latex
    \begin{tcolorbox}
      \begin{equation*}
        P_x(e^{j\omega}) = DTFT\{r_x[n]\}
      \end{equation*}
    \end{tcolorbox}
  #+end_src

  where each sample of the \textcolor{blue}{autocrrelation} is obtained by taking the Expectation
  of the product of the stochastic signal times a delayed copie of itself:

  #+begin_src latex
  \begin{tcolorbox}
    \begin{equation*}
      r_x[n] = E\left[x[k]x[n+k] \right]
    \end{equation*}
  \end{tcolorbox}
  #+end_src


- for a filtered stochastic process $y[n] = H\{x[n]\}$ the general result is
  that the power spectral density (PSD) is equal to the PSD of the input times
  the frequency response in magnitude square.
   #+begin_src latex
     \begin{tcolorbox}
       \begin{equation*}
         P_y(e^{j\omega}) = |H(e^{j\omega})|^2 P_x(e^{j\omega})
       \end{equation*}
     \end{tcolorbox}
 #+end_src
 
  #+ATTR_LATEX: :options [logo=\bcbook, couleur=yellow!10, barre=snake, arrondi=0.1]{General Result for a Stochaistic Process}
  #+BEGIN_bclogo
  The power spectral density of the output of a LTI system is equal to the power spectral density
  of the input times squared magnitude of the Fourier transform of the filter frequency response.
  #+END_bclogo

  - Key Results ::
    - filters designed for deterministic signals work (in magnitude) in the
      stochaistic case
    - we lose the concept of phase since we don't know the shape of a realization in
      advance. All we know is the PSD in frequency

**** Noise
- Noise is everywhere ::
  - thermal noise
  - sum of extraneous interferences
  - quantization and numerical errors
  - ...
- *we can model noise as a stochastic signal*
- the most important noise is white noise 
**** White noise
- white indicates uncorrelated samples
- $r_w[n] = \sigma^2\delta[n]$: The autocorrleation is zero except at zero where
  it will take the value of the variance
- $P_w(e^{j\omega} = \sigma^2$: The power spectral density is the constant
  $\sigma^2$ where $\sigma$ is the variance of the stochastic signal.

Graphically the power spectral density of a white signal couldn't be any simpler.
#+BEGIN_SRC octave :exports results :results file
  pkg load signal
  w = -pi:pi+1;
  sigma = w./w;

  figure( 1, "visible", "off" )               # Do not open the graphic window in org
  title("White Noise")
  plot(w, sigma, "linewidth", 2); % amplitude plot in decibel
  grid('off');
  axis([-pi pi 0 1.2])
  axis("nolabel");
  set(gca, "fontsize", 24);
  set(gca,'XTick',-pi:pi/2:pi)
  set(gca,'XTickLabel',{'-\pi','-\pi/2','0','\pi/2','\pi'});
  text(-3.25      ,  1, '\fontsize{24}\it\sigma^2   ',  "color",  "red",  "interpreter",  "tex",  "horizontalalignment",  "center");
  ylabel("P_{w}(e^{jw})");
  print -dpng "-S800,200" ./image/5_5_white_noise_01.png;
  ans = "./image/5_5_white_noise_01.png";
 #+END_SRC

 #+results:
 [[file:./image/5_5_white_noise_01.png]]

- the PSD is independent of the probability distribution of the *single* samples (depends only on the variance)
- distribution is important to estimate bounds for the signal
- very often a Gaussian distribution models the experimental data the best
- *AWN*: additive white Gaussian noise

#+ATTR_LATEX: :options [logo=\bcbook, couleur=yellow!10, barre=snake, arrondi=0.1]{Power Spectral Density}
#+BEGIN_bclogo
- The PSD of a random signal is the average squared magnitude of its Fourier
  transform. The average is taken across multiple realizations of the
  process.
- The PSD is the Fourier transform of the autocorrelation function
- The BSD of the output of a LEI system is the product of the BSD of the input
  and squared magnitude of the Fourier transform of the filter frequency
  response.
#+END_bclogo

*** Quantization
**** Quantization schemes
- digital devices can only deal with integers (b bits per sample)
- we need to map the range of a signal onto a finite set of values
- irreverible loss of information $\longrightarrow$ \textcolor{blue}{Quantization Noise}

#+begin_src ditaa :file ./image/w7_quantization_concept.png
                +------+
                |      |
       x[n] --->+ Q{.} +---> x^[n] 
                |      |
                +------+
#+end_src
#+ATTR_LATEX: :width 0.4\textwidth :wrap
#+results:
[[file:./image/w7_quantization_concept.png]]

Several factors at play:
- storage budget (bits per sample)
- storage scheme (fixed point, floating point)
- properties of the input (input \in $\mathbb{C} \rightarrow$ output $\in \mathbb{N}$

**** Scalar quantization

The simplest quantizer:
- each sample is encoded individually (hence scalar)
- each sample is quantized independently (memoryless quantization)
- each sample is encoded using R bits

  #+begin_src latex
    \begin{tikzpicture}[x=5.2mm,scale=1,>=stealth]
      \node at (10mm,0) {k = 00};
      \node at (30mm,0) {k = 01};
      \node at (50mm,0) {k = 10};
      \node at (70mm,0) {k = 11};
      \node at (0,-0.5) {A};
      \node at (15.4,-0.5) {B};
      \draw[line width=2pt] (0,-1) -- (15.4,-1);

      \foreach \val [count=\x] in {0,...,4}
        \draw[line width=2pt] (20* \val mm, -0.7) -- (20*\val mm, -1.3);
      \foreach \val [count=\x] in {0,...,4}
        \draw (20* \val mm, -1.3)
        node[anchor=north] {$i_\val$};
      \foreach \val [count=\x] in {0,...,3}
         \draw (10* \val mm + 10mm + 10* \val mm, -1)
           node[circle,fill=black,inner sep=0pt,minimum size=3pt]{};
       \foreach \val [count=\x] in {0,...,3}
         \draw (10* \val mm + 10mm + 10* \val mm, -0.8)
           node[anchor=south] {$\hat{x}_\val$};
      \foreach \val [count=\x] in {0,...,3}
        \draw (10* \val mm + 10mm + 10* \val mm, -1.5)
           node[anchor=north] {$I_\val$};
    \end{tikzpicture}
  #+end_src

- what are the optimal interval boundries $I_k$ ?

- what are the optimal quantization values $\hat{x}_k$ ?

**** Quantization Error
#+begin_src latex
  \begin{equation*}
    e[n] = Q \left\{x[n] \right\} -x[n] = \hat{x}[n] - x[n]
  \end{equation*}
#+end_src

- model x[n] as a stochastic process
- model error as a white noise sequence
  - error samples are uncorrelated
  - all error samples have the same distribution
- we need statistics of the input to study the error

***** Uniform quantization
- simple but very general case
- range is split into $2^R$ equal intervals of width $\Delta = (B-A)2^{-R}$

- $f_x(\tau)$: PDF of the input

- *With a Bit-Rate R* of 2 bits is a region split into 4 equally spaced
  intervals\\

    #+begin_src latex
    \begin{tikzpicture}[x=5.2mm,scale=1,>=stealth]
      \node at (0,0) {A};
      \node at (15.4,0) {B};
      \draw[line width=2pt] (15.4,-0.2) -- (15.4,-0.5);
      \draw[line width=2pt] (0,-0.5) -- (15.4,-0.5);
      \foreach \val [count=\x] in {0,...,4}
        \draw[line width=2pt] (20* \val mm, -0.2) -- (20*\val mm, -0.8);
      \foreach \val [count=\x] in {0,...,4}
        \draw (20* \val mm, -0.8)
        node[anchor=north] {i-$\x$};
      \foreach \val [count=\x] in {0,...,3}
        \draw (10* \val mm + 10mm + 10* \val mm, -1)
           node[anchor=north] {$\Delta$};
    \end{tikzpicture}
  #+end_src

  Mean Square Error is the variance of the error signal

  #+begin_src latex
      \begin{align*}
        \sigma_e^2 &= E\left[|Q\left\{x[n]\right\} -x[n]|^2\right] \\
                   &= \int_A^Bf_x(\tau)(Q\left\{\tau\right\} -\tau)^2 d\tau \\
                   &= \sum_{k=0}^{2^R-1} \int_{I_k} f_x(\tau)(\hat{x}_k - \tau)^2 d\tau
    \end{align*}
  #+end_src
- $Q\left\{\tau\right\} -\tau$ : Error function

error depends on the probability density of the input. The calculation is done
in the following subsections here we already subsitutes the results.

  #+begin_src latex
    \begin{align*}
        \sigma_e^2 &= \sum_{k=0}^{2^R-1} \int_{A+k\Delta}^{A+k\Delta+k} \frac{(A + k\Delta + \Delta/2 - \tau)^2}{B-A} d\tau \\
                   &= 2^R \int_0^\Delta \frac{(\Delta/2 -\tau)^2}{B-A} d\tau \\
                   &= \frac{\Delta^2}{12} \text{ with }   \Delta = \frac{B-A}{2^R}
    \end{align*}
  #+end_src

#+begin_src latex
    \begin{tcolorbox}[colback=red!5!white,colframe=red!75!black,title=Quantization Error]
    \begin{equation*}
        \sigma_e^2 = \frac{\Delta^2}{12} \text{ with }  \Delta = \frac{B-A}{2^R}
    \end{equation*}
  \end{tcolorbox}
#+end_src

***** Uniform quantization of uniform input

#+begin_src octave :exports results :results file
    # Algorithm --------------------------------------------------------------
  N = 20;
    A = -2;
    B = 6;
    x = (-N/2:0.01:N/2);
    f = @(x) (1.0/(B-(-A))).*(((x-A)>=0)&(x<B)); # Rectpuls
    # x = [(((n-A)>=0)&(n<B))]                   # not as anonymous function
    # Graphik ----------------------------------------------------------------
    figure(1, "visible", "off");      # Do not open the graphic window in org
    # Plot 1 -----------------------------------------------------------------^
    plot(x,f(x), "linewidth", 3);
    axis([-N/2 N/2 -0.1 1.1]);
    xlabel('\tau');
    ylabel('f_x(\tau)');
    text(-5.5,(1.0/(B+A)),'1/(B-A) \rightarrow','FontSize',32, 'horizontalalignment', 'left')
    text(A,0.5,'A','FontSize',32, 'horizontalalignment', 'center')
    text(A,0.38,'\downarrow','FontSize',32, 'horizontalalignment', 'center')
    text(B,0.5,'B','FontSize',32, 'horizontalalignment', 'center')
    text(B,0.38,'\downarrow','FontSize',32, 'horizontalalignment', 'center')

    title('Continous uniform probability density function');
    set(gca, "fontsize", 24);
    grid on ;
    # Org-Mode specific output -----------------------------------------------
    print -dpng "-S800,200" ./image/w7_uniform_pdf.png; # Set print device
    ans = "./image/w7_uniform_pdf.png";                 # The mandtory return value
#+end_src

#+results:
[[file:./image/w7_uniform_pdf.png]]

***** Uniform-input hypothesis
#+begin_src latex
  \begin{equation*}
    f_x(\tau) = \frac{1}{B-A}
  \end{equation*}
#+end_src

#+begin_src latex
  \begin{equation*}
    \sigma^2 = \sum_{k=0}^{2^R-1} \int_{I_k}\frac{(\hat{x} -\tau)^2}{B-A} d\tau
  \end{equation*}
#+end_src

***** Find the optimal quantization point by minimazing the error 

#+begin_src latex
  \begin{align*}
    \frac{\partial\sigma_e^2}{\partial\hat{x}_m} &= \frac{\partial}{\partial\hat{x}_m} \sum_{k=0}^{2^R-1} \int_{I_k}\frac{(\hat{x}_k -\tau)^2}{B-A} d\tau \\
                                                 &= \int_{I_m}\frac{2(\hat{x}_m -\tau)^2}{B-A} d\tau \\
                                                 &= \frac{2(\hat{x}_m -\tau)^2}{B-A} \Big|_{A+m\Delta}^{A+m\Delta+\Delta} 
  \end{align*}
#+end_src


Minimizing the error:

#+begin_src latex
  \begin{equation*}
    \frac{\partial\sigma_e^2}{\partial\hat{x}_m} = 0 \text{ for } \hat{x}_m = A + m\Delta + \frac{\Delta}{2}
  \end{equation*}
#+end_src

optimal quantization point is the interval's midpoint, for all intervals
***** TODO COMMENT Correct this PGF Plot
Quantization Characteristic
#+begin_src latex
  % linear uniform mid-tread quantizer characteristic
  \pgfplotsset{axis style={mathaxis,ytick={1,2,3,4},yticklabels={\tiny $Q$},xtick={-4,0.5,4},xticklabels={\tiny $x_\text{min}$, \tiny $\frac{Q}{2}$,\tiny $x_\text{max}$},xlabel=$x$,}}

  \begin{tikzpicture}

    \begin{axis}[ylabel={$x_Q$}]
      \addplot[blue,thick] plot coordinates{(-6,-4) (-3.5,-4) (-3.5,-3) (-2.5,-3) (-2.5,-2) (-1.5,-2) (-1.5,-1) (-.5,-1) (-.5,0) (.5,0) (.5,1) (1.5,1) (1.5,2) (2.5,2) (2.5,3) (3.5,3) (3.5,4) (6,4) };
      \addplot[red,dashed,domain=-5:5,samples=50] { x };
    \end{axis};

  \end{tikzpicture}
#+end_src

The quantiziser associates each quantization interval to its midpoint.  

**** Error Analysis 
dummy - text
#+begin_src latex
    \begin{tcolorbox}[colback=red!5!white,colframe=red!75!black,title=Error Energy]
    \begin{equation*}
        \sigma_e^2 = \frac{\Delta^2}{12} \text{ with }  \Delta = \frac{B-A}{2^R}
    \end{equation*}
  \end{tcolorbox}
#+end_src

#+begin_src latex
    \begin{tcolorbox}[colback=red!5!white,colframe=red!75!black,title=Signal Energy]
    \begin{equation*}
        \sigma_x^2 = \frac{(B-A)^2}{12}
    \end{equation*}
  \end{tcolorbox}
#+end_src

#+begin_src latex
  \begin{tcolorbox}[colback=red!5!white,colframe=red!75!black,title=Signal to Noise Ratio]
    \begin{equation*}
        SNR = 2^{2R}
    \end{equation*}
  \end{tcolorbox}
#+end_src

#+begin_src latex
  \begin{tcolorbox}[colback=red!5!white,colframe=red!75!black,title=Signal to Noise Ratio in db]
    \begin{equation*}
        SNR_{db} = 10\cdot log_{10}2^{2R} \approx 6R \;db
    \end{equation*}
  \end{tcolorbox}
#+end_src

*** The 6db/bit rule of thumb
- a compact disk has 16 bits/sample:
  #+begin_src latex
    \begin{equation*}
        max SNR_{db} =\approx 6R \;db = 6 \cdot 16\; db = 96\;db
    \end{equation*}
#+end_src

- a DVD has 24 bits/sample:
    #+begin_src latex
    \begin{equation*}
        max SNR_{db} =\approx 6R \;db = 6 \cdot 24\; db = 144\;db
    \end{equation*}
#+end_src

** Notes and External Resources

*** TODO Clipping, saturation and interpolation
*** Practical interpolation and sampling
**** Time Domain to Discrete
| ideally                                                                                                     | x(t) $\Rightarrow$ x[n]  | in practice                                                                                                        |
| $x(t) = \sum_{n=-\infty}^{\infty} x[n] sinc \left(frac{t -nT_s}{T_s} \right)$                               |                          | $x(t) =\sum_{n=-\infty}^{\infty}  x[n] i \left( \frac{t -nT_s}{T_s} \right)$                                                                |
| $X(j\Omega) = \frac{\pi}{\Omega_N}X(e^{j\pi\Omega / \Omega_N}) rect\left( \frac{\Omega}{2\Omega_N}\right)$  |                          | $X(j\Omega) = \frac{\pi}{\Omega_N} I \left(j\pi\frac{\Omega}{\Omega_N} \right) X(e^{j\pi\frac{\Omega}{\Omega_N}})$ |


**** Discrete to Time Domain

| ideally                                                                                                       | x[n] $\Rightarrow$ x(t)  | in practice                                                                                                          |
| $x(t) = \sum_{-\infty}^{\infty} x[n] sinc \left( \frac{t-nT_s}{T_s} \right)$                                  |                          | $x(t) = \sum_{n=-\infty}^{\infty} x[n]\, i\, \left( \frac{t-nT_s}{T_s} \right)$                                      |
| $X(j\Omega) = \frac{\pi}{\Omega_N} X(e^{j\pi\Omega / \Omega_n} rect\left( \frac{\Omega}{2\Omega_N} \right)$)  |                          | $X(j\Omega) = \frac{\pi}{\Omega_N} I \left(j\pi \frac{\Omega}{\Omega_N} \right) X(e^{j\pi \frac{\Omega}{\Omega_N}})$ |

***** Ideal Interpolator
- Frequency Domain: Rect
- Time Domain: sinc
#+begin_src octave :exports results :results file
  N = 64                          # Size of the sequence
  q = 5;                          # divisior for Omega_N
  Omega_N = pi/q;                 # Nyquiste Frequency
  omega = -pi:1/N:pi;             # Axis Discrete Time Frequency Domain
  Omega = pi.*omega./Omega_N;     # Axis Continous Time Frequency Domain - phase term from sinc interpolation

  XD = 0.43*(sin(omega+pi/2) + 0.5*cos(2*omega+pi)) + 0.66;     # DTFT{x[n]} (given)
  XT = (0.43*(sin(Omega+pi/2) + 0.5*cos(2*Omega+pi)) + 0.66);   # FT{x(t)} => Rescaled version of DTFT{x[n]}
  I = (((omega + Omega_N) >= 0) - ((omega - Omega_N) >= 0));    # rect:   ideal interpolator function
  # I = abs(sinc(omega*pi/2));                                    # sinc:   Zero order hold sinc
  # I = abs(sinc(omega*pi/2).^2)                                  # sinc^2: First order interpolator

  figure( 1, "visible", "off" )     # Do not open the graphic window in org

  subplot(3,1,1)
  plot(omega, XD, "linewidth", 2 );
  axis([-pi,pi,0,1.3]);
  set(gca, "fontsize", 20)
  set(gca,'XTick',-pi:pi/2:pi)
  set(gca,'XTickLabel',{'-\pi','-\pi/2','0','\pi/2','\pi'})
  set(gca, 'YTick', 0:1);
  ylabel('X(e^j^\omega)');
  grid off;
  title('DTFT of the sequence')

  subplot(3,1,2)
  plot(omega, XT, "linewidth", 2);
  hold;
  plot(omega, I, "linewidth", 2, "color", "red" );
  axis([-pi,pi,0,1.3]);
  set(gca, "fontsize", 20)
  set(gca,'XTick',[-q*Omega_N:2*Omega_N:-Omega_N, 0, Omega_N:2*Omega_N:q*Omega_N])
  set(gca,'XTickLabel',{'-3\Omega_N','-2\Omega_N', '\Omega_N','0','\Omega_N', '2\Omega_N','3\Omega_N'})
  set(gca, 'YTick', 2);
                                  #set(gca, 'YTickLabel',{'0', '1'})
  ylabel('X(j\Omega)');
  grid off;
  title('Periodic \omega mapped to \Omega with ideal Interpolator')

  subplot(3,1,3)
  plot(omega, XT.*I, "linewidth", 2 );
  axis([-pi,pi,0,1.3]);
  set(gca, "fontsize", 20)
  set(gca,'XTick',[-q*Omega_N:2*Omega_N:-Omega_N, 0, Omega_N:2*Omega_N:q*Omega_N])
  set(gca,'XTickLabel',{'-5\Omega_N','-3\Omega_N', '\Omega_N','0','\Omega_N', '3\Omega_N','5\Omega_N'})
  set(gca, 'YTick', 2);
  ylabel('X(j\Omega)');
  title('Resulting continous time spectrum')
  grid off


  print -dpng "-S800,600" ./image/w7_ideal_interpolation_01.png;
  ans = "./image/w7_ideal_interpolation_01.png";
#+end_src

#+results:
[[file:./image/w7_ideal_interpolation_01.png]]

***** Zero-Order Hold Interpolator
- Frequency Domain: sinc
- Time Domain: rect
#+begin_src octave :exports results :results file
  N = 64                          # Size of the sequence
  q = 5;                          # divisior for Omega_N
  Omega_N = pi/q;                 # Nyquiste Frequency
  omega = -pi:1/N:pi;             # Axis Discrete Time Frequency Domain
  Omega = pi.*omega./Omega_N;     # Axis Continous Time Frequency Domain - phase term from sinc interpolation

  XD = 0.43*(sin(omega+pi/2) + 0.5*cos(2*omega+pi)) + 0.66;     # DTFT{x[n]} (given)
  XT = (0.43*(sin(Omega+pi/2) + 0.5*cos(2*Omega+pi)) + 0.66);   # FT{x(t)} => Rescaled version of DTFT{x[n]}
  # I = (((omega + Omega_N) >= 0) - ((omega - Omega_N) >= 0));    # rect:   ideal interpolator function
  I = abs(sinc(omega*pi/2));                                    # sinc:   Zero order hold sinc
  # I = abs(sinc(omega*pi/2).^2)                                  # sinc^2: First order interpolator

  figure( 1, "visible", "off" )     # Do not open the graphic window in org

  subplot(3,1,1)
  plot(omega, XD, "linewidth", 2 );
  axis([-pi,pi,0,1.3]);
  set(gca, "fontsize", 20)
  set(gca,'XTick',-pi:pi/2:pi)
  set(gca,'XTickLabel',{'-\pi','-\pi/2','0','\pi/2','\pi'})
  set(gca, 'YTick', 0:1);
  ylabel('X(e^j^\omega)');
  grid off;
  title('DTFT of the sequence')

  subplot(3,1,2)
  plot(omega, XT, "linewidth", 2);
  hold;
  plot(omega, I, "linewidth", 2, "color", "red" );
  axis([-pi,pi,0,1.3]);
  set(gca, "fontsize", 20)
  set(gca,'XTick',[-q*Omega_N:2*Omega_N:-Omega_N, 0, Omega_N:2*Omega_N:q*Omega_N])
  set(gca,'XTickLabel',{'-3\Omega_N','-2\Omega_N', '\Omega_N','0','\Omega_N', '2\Omega_N','3\Omega_N'})
  set(gca, 'YTick', 2);
                                  #set(gca, 'YTickLabel',{'0', '1'})
  ylabel('X(j\Omega)');
  grid off;
  title('Periodic \omega mapped to \Omega with zero-order hold Interpolator')

  subplot(3,1,3)
  plot(omega, XT.*I, "linewidth", 2 );
  axis([-pi,pi,0,1.3]);
  set(gca, "fontsize", 20)
  set(gca,'XTick',[-q*Omega_N:2*Omega_N:-Omega_N, 0, Omega_N:2*Omega_N:q*Omega_N])
  set(gca,'XTickLabel',{'-5\Omega_N','-3\Omega_N', '\Omega_N','0','\Omega_N', '3\Omega_N','5\Omega_N'})
  set(gca, 'YTick', 2);
  ylabel('X(j\Omega)');
  title('Resulting continous time spectrum')
  grid off


  print -dpng "-S800,600" ./image/w7_ideal_zero_order_hold_interpolation_01.png;
  ans = "./image/w7_ideal_zero_order_hold_interpolation_01.png";
#+end_src

#+results:
[[file:./image/w7_ideal_zero_order_hold_interpolation_01.png]]

***** First-Order Interpolator

- Frequency Domain: $sinc^2$
- Time Domain: Triangle
#+begin_src octave :exports results :results file
  N = 64                          # Size of the sequence
  q = 5;                          # divisior for Omega_N
  Omega_N = pi/q;                 # Nyquiste Frequency
  omega = -pi:1/N:pi;             # Axis Discrete Time Frequency Domain
  Omega = pi.*omega./Omega_N;     # Axis Continous Time Frequency Domain - phase term from sinc interpolation

  XD = 0.43*(sin(omega+pi/2) + 0.5*cos(2*omega+pi)) + 0.66;     # DTFT{x[n]} (given)
  XT = (0.43*(sin(Omega+pi/2) + 0.5*cos(2*Omega+pi)) + 0.66);   # FT{x(t)} => Rescaled version of DTFT{x[n]}
  # I = (((omega + Omega_N) >= 0) - ((omega - Omega_N) >= 0));    # rect:   ideal interpolator function
  # I = abs(sinc(omega*pi/2));                                    # sinc:   Zero order hold sinc
  I = abs(sinc(omega*pi/2).^2)                                  # sinc^2: First order interpolator

  figure( 1, "visible", "off" )     # Do not open the graphic window in org

  subplot(3,1,1)
  plot(omega, XD, "linewidth", 2 );
  axis([-pi,pi,0,1.3]);
  set(gca, "fontsize", 20)
  set(gca,'XTick',-pi:pi/2:pi)
  set(gca,'XTickLabel',{'-\pi','-\pi/2','0','\pi/2','\pi'})
  set(gca, 'YTick', 0:1);
  ylabel('X(e^j^\omega)');
  grid off;
  title('DTFT of the sequence')

  subplot(3,1,2)
  plot(omega, XT, "linewidth", 2);
  hold;
  plot(omega, I, "linewidth", 2, "color", "red" );
  axis([-pi,pi,0,1.3]);
  set(gca, "fontsize", 20)
  set(gca,'XTick',[-q*Omega_N:2*Omega_N:-Omega_N, 0, Omega_N:2*Omega_N:q*Omega_N])
  set(gca,'XTickLabel',{'-3\Omega_N','-2\Omega_N', '\Omega_N','0','\Omega_N', '2\Omega_N','3\Omega_N'})
  set(gca, 'YTick', 2);
                                  #set(gca, 'YTickLabel',{'0', '1'})
  ylabel('X(j\Omega)');
  grid off;
  title('Periodic \omega mapped to \Omega with first-order Interpolator')

  subplot(3,1,3)
  plot(omega, XT.*I, "linewidth", 2 );
  axis([-pi,pi,0,1.3]);
  set(gca, "fontsize", 20)
  set(gca,'XTick',[-q*Omega_N:2*Omega_N:-Omega_N, 0, Omega_N:2*Omega_N:q*Omega_N])
  set(gca,'XTickLabel',{'-5\Omega_N','-3\Omega_N', '\Omega_N','0','\Omega_N', '3\Omega_N','5\Omega_N'})
  set(gca, 'YTick', 2);
  ylabel('X(j\Omega)');
  title('Resulting continous time spectrum')
  grid off


  print -dpng "-S800,600" ./image/w7_first_order_interpolation_01.png;
  ans = "./image/w7_first_order_interpolation_01.png";
#+end_src

#+results:
[[file:./image/w7_first_order_interpolation_01.png]]

*** TODO Bandbass sampling
*** Multirate Signal Processing
[[http://home.etf.rs/~milic/book_MR.html][Book: Multirate Filtering for Digital Signal Processing Matlab Applications]]
**** Upsampling

#+begin_src latex
  \begin{equation*}
    x_{NU}[n] = \left\{
      \begin{array}{ll}
        x[k] \text{  for } n = kN \text{, } k \in \mathbb{Z} \\
        0 \text{     otherwise}
      \end{array}
    \right.
  \end{equation*}
#+end_src

#+ATTR_LATEX: :width 5cm
[[file:./drawing/w7_upsampler.png]]

We create an upsampled sequence from any discrete time sequence simply by
building a sequence where we output one sample of the original sequence followed
by captial N minus 1 samples.


#+BEGIN_SRC octave :exports results :results file
  pkg load signal

  clear all, close all;
  N = 64;
  n = -N/2:N/2-1;                                      % Time index
  L = 4;                                           % Up-sampling factors
  x = sin(2*pi*n/64) + sin(3*2*pi*n/64)/3;       % Generating the original signal
  v1 = upsample(x,L);                              % Up-sampling
  r = -(length(v1))/2:(length(v1))/2-1;                              % new Time index
  figure( 1, "visible", "off" ); # Do not open the graphic window in org

  subplot(3,1,1), stem(n,x,"linewidth", 3, "filled", "markersize", 4), ylabel('x[n]')
  title('Original signal x[n]')
  axis([-N/2,N/2-1,-1,1]), grid on;
  set(gca, "fontsize", 24);

  subplot(3,1,2), stem(n,x,"linewidth", 3, "filled", "markersize", 4), ylabel('x[n]')
  title('Excerpt from x[n]')
  set(gca, "fontsize", 24);
  axis([-8, 8, -1, 1]);
  set(gca, 'YTick', 0:1.5);
  set(gca, 'XTick', -8:2:8);

  subplot(3,1,3), stem(r,v1,"linewidth", 3, "filled", "markersize", 4), ylabel('v_1[r]')
  title('Up-sampled-by-4 signal v_1[r]')
  axis([-32, 32, -1, 1]);
  set(gca, "fontsize", 24);
  set(gca, 'YTick', 0:1.5);
  set(gca, 'XTick', -40:10:40);
  grid off;
  title('Excerpt upsampled by 4');


  print -dpng "-S800,600" ./image/5_8_upsampling_01.png;
  ans = "./image/5_8_upsampling_01.png";
 #+END_SRC

 #+results:
 [[file:./image/5_8_upsampling_01.png]]

- Spectral Representation
   #+begin_src latex
  \begin{tcolorbox}[colback=red!5!white,colframe=red!75!black,title=Spectral Representation]
  \begin{equation*}
    X_{NU}(e^{j\omega}) = X(e^{j\omega N})
  \end{equation*}
  \end{tcolorbox}
#+end_src
  The spectrum of the upsampled sequence is equal to the spectrum of the
  original sequence contracted by a factor N.

  #+BEGIN_SRC octave :exports results :results file
   pkg load signal

   clear all, close all;
   N = 64;

   L = 1; omega    = -L*pi:1/(N-1):pi*L;   % Up-sampling factors
   L = 2; omega_u2 = -L*pi:1/(N-1):pi*L;   % Up-sampling factors
   L = 3; omega_u3 = -L*pi:1/(N-1):pi*L;   % Up-sampling factors
   P = 5; omega_p5 = -P*pi:1/(N-1):pi*P;   % For 5-pi periodic space

   X        = abs(-sawtooth(10/N*pi*omega,0.5));
   X_period = abs(-sawtooth(10/N*pi*omega_p5,0.5));
   XU2      = abs(-sawtooth(10/N*pi*omega_u2,0.5));
   XU3      = abs(-sawtooth(10/N*pi*omega_u3,0.5));

   figure( 1, "visible", "off" ); # Do not open the graphic window in org

   subplot(4,1,1), plot(omega,X,"linewidth", 3), ylabel('X(e^j^\omega)')
   axis([-pi,pi,0,1]);
   set(gca, "fontsize", 20)
   set(gca,'YTick', 0:1)
   set(gca,'XTick',-pi:pi:pi)
   set(gca,'XTickLabel',{'-\pi','0','\pi'})
   title('Spectrum')

   subplot(4,1,2), plot(omega_p5,X_period,"linewidth", 3), ylabel('X(e^j^\omega)')
   axis([-pi*P,pi*P,0,1]);
   set(gca, "fontsize", 20)
   set(gca,'YTick', 0:1)
   set(gca,'XTick',-pi*P:pi:pi*P)
   set(gca,'XTickLabel',{'-5\pi','-4\pi','-3\pi','-2\pi','-\pi','0','\pi','2\pi','3\pi','4\pi','5\pi'})
   title('2\pi periodic spectrum')

  subplot(4,1,3),
  plot(omega_u2,XU2,"linewidth", 3), ylabel('X_2_U(e^j^\omega)')
  axis([-2*pi,2*pi,0,1]);
  set(gca, "fontsize", 20)
  set(gca,'YTick', 0:1)
  set(gca,'XTick',-2*pi:2*pi:2*pi)
  set(gca,'XTickLabel',{'-\pi','0','\pi'})
  grid off;
  title('Contracted Spectrum by Factor 2')

  subplot(4,1,4),
  plot(omega_u3,XU3,"linewidth", 3), ylabel('X_2_U(e^j^\omega)')
  axis([-3*pi,3*pi,0,1]);
  set(gca, "fontsize", 20)
  set(gca,'YTick', 0:1)
  set(gca,'XTick',-3*pi:3*pi:3*pi)
  set(gca,'XTickLabel',{'-\pi','0','\pi'})
  grid off;
  title('Contracted Spectrum by Factor 3')

  print -dpng "-S800,600" ./image/5_8_upsampling_freq_01.png;
  ans = "./image/5_8_upsampling_freq_01.png";
     #+END_SRC

 #+results:
 [[file:./image/5_8_upsampling_freq_01.png]]

- Non fullband spectrum
  #+BEGIN_SRC octave :exports results :results file
         pkg load signal

         clear all, close all;
         N = 64;

         L = 1; omega    = -L*pi:1/(N-1):pi*L;   % Up-sampling factors
         L = 2; omega_u2 = -L*pi:1/(N-1):pi*L;   % Up-sampling factors
         L = 4; omega_u4 = -L*pi:1/(N-1):pi*L;   % Up-sampling factors
         P = 5; omega_p5 = -P*pi:1/(N-1):pi*P;   % For 5-pi periodic space

         X       =  tripuls(omega,4/3*pi);
         XP5      = [X,X,X,X,X];
         XU2      = [X,X];
         XU4      = [X(199:396),X,X,X,X(1:198)];
         XU4      = [X(length(X)/2+1:length(X)),X,X,X,X(1:length(X)/2)];

         figure( 1, "visible", "off" ); # Do not open the graphic window in org

       subplot(3,1,1), plot(omega,X,"linewidth", 3), ylabel('X(e^j^\omega)')
       axis([-pi,pi,0,1]);
       set(gca, "fontsize", 20)
       set(gca,'YTick', 0:1)
       set(gca,'YTick', 0:1)
       set(gca,'XTick',-pi:pi:pi)
       set(gca,'XTickLabel',{'-\pi','0','\pi'})
       title('Spectrum')

       subplot(3,1,2),
       plot(omega_p5,XP5,"linewidth", 3), ylabel('X(e^j^\omega)')
       axis([-pi*P,pi*P,0,1]);
       set(gca,'YTick', 0:1)
       set(gca, "fontsize", 20)
       set(gca,'XTick',-pi*P:pi:pi*P)
       set(gca,'XTickLabel',{'-5\pi','-4\pi','-3\pi','-2\pi','-\pi','0','\pi','2\pi','3\pi','4\pi','5\pi'})
       title('2\pi periodic spectrum')

       subplot(3,1,3),
       plot(omega_u4,XU4,"linewidth", 3), ylabel('X_2_U(e^j^\omega)')
       axis([-4*pi,4*pi,0,1]);
       set(gca, "fontsize", 20)
       set(gca,'YTick', 0:1)
       set(gca,'XTick',-4*pi:4*pi:4*pi)
       set(gca,'XTickLabel',{'-\pi','0','\pi'})
       grid off;
       title('Contracted Spectrum by Factor 3')

       print -dpng "-S800,600" ./image/5_8_upsampling_freq_02.png;
       ans = "./image/5_8_upsampling_freq_02.png";
     #+END_SRC

     #+results:
     [[file:./image/5_8_upsampling_freq_02.png]]
***** What we don't like
- in the time domain: zeors between nonzero samples are not "natural"
- in the frequency domain: extra replicas of the spectrum; can we get rid of them?

  We need to interpolate the signals in the Frequency domain:
  - zero-order hold interpolator
  - first-order interpolator
    
***** The ideal digital interpolator

#+begin_src latex
  \begin{align*}
    H(e^{j\omega}) &= rect\left( frac{\omega N}{2\pi}\right) \\
    h[n] &= \frac{1}{N}sinc\left( \frac{n}{N}\right)
  \end{align*}
#+end_src

This can not be achieved but as good as possible add an Low Pass with cut off frequency $\frac{pi}{N}$,

#+ATTR_LATEX: :width 6cm
[[file:./drawing/w7_upsampler_LP.png]]

with a discrete time ideal low pass filter with cut off frequency $\pi/N$
**** Downsampling

#+begin_src latex
  \begin{equation*}
    x_{ND}[n] = x[nN]
  \end{equation*}
#+end_src


Every $N - 1$ input sample is discareded resp. only every N-th sample is used.
#+ATTR_LATEX: :width 5cm
[[file:./drawing/w7_downsampler.png]]

#+BEGIN_SRC octave :exports results :results file
  pkg load signal

  clear all, close all;
  n = 0:15;                                        % Time index
  L = 4; M = 3;                                    % Up-sampling and down-sampling factors
  x = cos(0.2*pi*n);                               % Generating the original signal
  v1 = upsample(x,L);                              % Up-sampling
  y1 = downsample(v1,M);                           % Down-sampling
  r = 0:length(v1)-1;                              % Time index
  m = 0:length(y1)-1;                              % Time index
  figure( 1, "visible", "off" ); # Do not open the graphic window in org

  v2 = downsample(x,M);                           % Down-sampling
  r = 0:length(v2)-1;                             % Time index
  y2 = upsample(v2,L);                            % Up-sampling
  m = 0:length(y2)-1;                             % Time index

  subplot(2,1,1), stem(n,x, "linewidth", 3, "filled", "markersize", 8), ylabel('x[n]')
  title('Original signal x[n]');
  axis([0,15,-1,1]), grid on;
  set(gca, "fontsize", 24);

  subplot(2,1,2), stem(r,v2, "linewidth", 3, "filled", "markersize", 8), ylabel('v_2[r]')
  title('Down-sampled-by-3 signal v_2[r]')
  axis([0,5,-1,1]), grid on;
  set(gca, "fontsize", 24);

  print -dpng "-S800,400" ./image/5_8_downsampling_01.png;
  ans = "./image/5_8_downsampling_01.png";
 #+END_SRC

 #+results:
 [[file:./image/5_8_downsampling_01.png]]

- Spectral Representation
  #+begin_src latex
  \begin{tcolorbox}[colback=red!5!white,colframe=red!75!black,title=Spectral Representation]
  \begin{equation*}
    X_{ND}(e^{j\omega}) = \frac{1}{N} \sum_{m=0}^{N-1} X(e^{j\frac{\omega - 2\pi m}{N}})
  \end{equation*}
  \end{tcolorbox}
  #+end_src

  There's 1/N normalization factor in front, that multiplies the sum of capital
  Ncopies of the original spectrum, where each copy has been shifted by a
  multiple of 2 pi/N, and where the frequency axis has been stretched out by a
  factor of capital N.  So the interval -pi/N, pi/N becomes the interval -pi,
  pi.
#+BEGIN_SRC octave :exports results :results file
        pkg load signal

        clear all, close all;
        N = 64;

        L = 1; omega    = -pi:1/(N-1):pi;   % Down-sampling factors
        L = 2; omega_d2 = -(2*pi/L):1/(N-1):(2*pi/L);   % Down-sampling factors
        P = 3; omega_p3 = -P*pi:1/(N-1):pi*P;   % For 5-pi periodic space

        # X       =  tripuls(omega,pi);
        X            =  tripuls(omega,pi);
        XP3          = [X,X,X];
        XP3_Sample   = [X(199:396),X,X,X(1:198)];
        XD2          = 1/L*[X];

        figure( 1, "visible", "off" ); # Do not open the graphic window in org

      subplot(3,1,1), plot(omega,X,"linewidth", 3), ylabel('X(e^j^\omega)')
      axis([-pi,pi,0,1]);
      set(gca, "fontsize", 20)
      set(gca,'YTick', 0:1)
      set(gca,'YTick', 0:1)
      set(gca,'XTick',-pi:pi/2:pi)
      set(gca,'XTickLabel',{'-\pi', '-\pi/2','0','\pi/2','\pi'})
      title('Spectrum')

      subplot(3,1,2)
  #    plot(omega_p3,XP3_Sum,"linewidth", 3);
      plot(omega_p3,XP3,"linewidth",3, omega_p3,XP3_Sample,"linewidth",3);
      ylabel('X(e^j^\omega)')
      axis([-pi*P,pi*P,0,1]);
      set(gca,'YTick', 0:1)
      set(gca, "fontsize", 20)
      set(gca,'XTick',-pi*P:pi/2:pi*P)
      set(gca,'XTickLabel',{'-3\pi','-5\pi/2','-2\pi','-3\pi/2','-\pi','-\pi/2','0','\pi/2','\pi','3\pi/2','2\pi','5\pi/2','3\pi'})
      title('2\pi periodic spectrum')

      subplot(3,1,3),
      plot(omega_d2,XD2,"linewidth", 3), ylabel('X_2_U(e^j^\omega)')
      axis([-pi/L,pi/L,0,1]);
      set(gca, "fontsize", 20)
      set(gca,'YTick', 0:1)
      set(gca,'XTick',-pi/L:pi/L:pi/L)
      set(gca,'XTickLabel',{'-\pi','0','\pi'})
      grid off;
      title('Expanded Spectrum')

      print -dpng "-S800,600" ./image/5_8_downsampling_freq_02.png;
      ans = "./image/5_8_downsampling_freq_02.png";
      #ans = length(omega_u2)
     #+END_SRC

     #+results:
     [[file:./image/5_8_downsampling_freq_02.png]]

- Downsampling by 2 with aliasing
  #+BEGIN_SRC octave :exports results :results file
    pkg load signal

    clear all, close all;
    N = 64;

    L = 1; omega    = -pi:1/(N-1):pi;   % Down-sampling factors
    L = 2; omega_d2 = -(2*pi/L):1/(N-1):(2*pi/L);   % Down-sampling factors
    P = 3; omega_p3 = -P*pi:1/(N-1):pi*P;   % For 5-pi periodic space

    X            =  tripuls(omega,3*pi/2);
    XP3          = [X,X,X];
    XP3_Sample   = [X(199:396),X,X,X(1:198)];
    XP3_Sum      = XP3 + XP3_Sample;
    XD2          = 1/L*[X];

    figure( 1, "visible", "off" ); # Do not open the graphic window in org

  subplot(3,1,1), plot(omega,X,"linewidth", 3), ylabel('X(e^j^\omega)')
  axis([-pi,pi,0,1]);
  set(gca, "fontsize", 20)
  set(gca,'YTick', 0:1)
  set(gca,'YTick', 0:1)
  set(gca,'XTick',-pi:pi/2:pi)
  set(gca,'XTickLabel',{'-\pi', '-\pi/2','0','\pi/2','\pi'})
  title('Spectrum')

  subplot(3,1,2)
  plot(omega_p3,XP3,"linewidth",1, omega_p3,XP3_Sample,"linewidth",1, omega_p3,XP3_Sum,"linewidth",4); 
  ylabel('X(e^j^\omega)')
  axis([-pi*P,pi*P,0,1]);
  set(gca,'YTick', 0:1)
  set(gca, "fontsize", 20)
  set(gca,'XTick',-pi*P:pi/2:pi*P)
  set(gca,'XTickLabel',{'-3\pi','-5\pi/2','-2\pi','-3\pi/2','-\pi','-\pi/2','0','\pi/2','\pi','3\pi/2','2\pi','5\pi/2','3\pi'})
  title('2\pi periodic spectrum')

  subplot(3,1,3),
  plot(omega_d2,XD2,"linewidth", 3), ylabel('X_2_U(e^j^\omega)')
  axis([-pi/L,pi/L,0,1]);
  set(gca, "fontsize", 20)
  set(gca,'YTick', 0:1)
  set(gca,'XTick',-pi/L:pi/L:pi/L)
  set(gca,'XTickLabel',{'-\pi','0','\pi'})
  grid off;
  title('Expanded Spectrum')

  print -dpng "-S800,600" ./image/5_8_downsampling_freq_alias-01.png;
  ans = "./image/5_8_downsampling_freq_alias-01.png";
  #ans = length(omega_u2)
     #+END_SRC

     #+results:
     [[file:./image/5_8_downsampling_freq_alias-01.png]]

- Downsampling by 2 with antialiasing filter
  #+BEGIN_SRC octave :exports results :results file
         pkg load signal

         clear all, close all;
         N = 64;

         L = 1; omega    = -pi:1/(N-1):pi;   % Down-sampling factors
         L = 2; omega_d2 = -(2*pi/L):1/(N-1):(2*pi/L);   % Down-sampling factors
         P = 3; omega_p3 = -P*pi:1/(N-1):pi*P;   % For 5-pi periodic space

         #X            =  tripuls(omega,3*pi/2);
         X            =  tripuls(omega,2*pi);
         X            = [zeros(1,100), X(100:295), zeros(1,100)];
         XP3          = [X,X,X];
         XP3_Sample   = [X(199:396),X,X,X(1:198)];
         XP3_Sum      = XP3 + XP3_Sample
         XD2          = 1/L*[X];

       figure( 1, "visible", "off" ); # Do not open the graphic window in org

       subplot(3,1,1), plot(omega,X,"linewidth", 3), ylabel('X(e^j^\omega)')
       axis([-pi,pi,0,1]);
       set(gca, "fontsize", 20)
       set(gca,'YTick', 0:1)
       set(gca,'YTick', 0:1)
       set(gca,'XTick',-pi:pi/2:pi)
       set(gca,'XTickLabel',{'-\pi', '-\pi/2','0','\pi/2','\pi'})
       title('Spectrum')

       subplot(3,1,2)
       plot(omega_p3, XP3_Sum,"linewidth", 3), ylabel('X(e^j^\omega)')
       axis([-pi*P,pi*P,0,1]);
       set(gca,'YTick', 0:1)
       set(gca, "fontsize", 20)
       set(gca,'XTick',-pi*P:pi/2:pi*P)
       set(gca,'XTickLabel',{'-3\pi','-5\pi/2','-2\pi','-3\pi/2','-\pi','-\pi/2','0','\pi/2','\pi','3\pi/2','2\pi','5\pi/2','3\pi'})
       title('2\pi periodic spectrum')

       subplot(3,1,3),
       plot(omega_d2,XD2,"linewidth", 3), ylabel('X_2_U(e^j^\omega)')
       axis([-pi/L,pi/L,0,1]);
       set(gca, "fontsize", 20)
       set(gca,'YTick', 0:1)
       set(gca,'XTick',-pi/L:pi/L:pi/L)
       set(gca,'XTickLabel',{'-\pi','0','\pi'})
       grid off;
       title('Expanded Spectrum')

       print -dpng "-S800,600" ./image/5_8_downsampling_freq_alias-02.png;
       ans = "./image/5_8_downsampling_freq_alias-02.png";
       ## ans = length(XP3)
     #+END_SRC

     #+results:
     [[file:./image/5_8_downsampling_freq_alias-02.png]]

     To avoid alisasing we have to filter the input sequence with a low-pass
     filter with cutoff frequency $\pi/N$, where N is the downsampling factor that will follow.
     
**** Sampling Rate Change

Downsampling and upsampling change the implicit sampling rate by integer
factor. But we can combine them so that the resulting sampling rate change will
be an aribtrary fractional number. The combination always goes in the sense that
we first upsample the signal, which is the operation that does not change the
information content of the original sequence, and then we perfrom downsampling.
#+ATTR_LATEX: :width 7cm
[[file:./drawing/w7_updownsampler_LP.png]]
Example:
- CD: $F_s = 44100Hz$
- DVD: $F_s = 48000Hz$
- $\frac{N}{M} = \frac{160}{147}$
- in practice,we use time-varying local interpolation
*** TODO FIR-based sampling rate conversion
- Sampling rate change through time-varying local interpolation
**** Subsample interpolation


**** 2nd-order Lagrange interpolation polynomials

**** Lagrange interpolation (N=1)

**** CD to DVD revisted
*** TODO Analog-to-digital and digital-to-analog converters
*** TODO Oversampling
- Oversampled A/D -> reduce quantization error
- Oversampled D/A -> use cheaper hardware for interpolation




